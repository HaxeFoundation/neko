<html>

<head>
<title>Neko Language Specification</title>
</head>
<body bgcolor="white">

<h1>Neko Language Specification</h1>

<h2>Introduction</h2>

<p>
Neko is an <i>intermediate</i> programming language designed to provide a common runtime for various imperative or functionnal, staticly or dynamicly typed high-level programming languages.
</p>

<p>
Every new programming language has now to deal with an huge amount of stuff in order to be taken seriously and labelled "usable". This can be some general properties such as an OO layer, decent runtime speed, dynamic loading  and reflection, but most of the work have to be put into librairies : Network, Xml, Internet protocols, Graphical User Interface, and so on... Such an amount of work makes new language long time to take off and the language designer can't focus anymore on features and design. This state has bring us to an era where outdated poor and uncool programming languages such as Java are ruling the business world, not because of its qualities and features but because of the ability of the industry to leverage it and reuse large librairies of code.
</p>

<p>
On the other side, Microsoft have an interesting approach with its DotNet platform : Free the language designer from a lot of work by providing a common framework being able to run a wide variety of languages. Looks very nice and promising on the paper, but there are several problems with it :
</p>

<ul>
<li>DotNet runs only on Windows (even if Mono is trying to keep up with it).</li>
<li>DotNet performs poorly with functional languages (until maybe <a href="http://research.microsoft.com/projects/ilx/ilx.aspx">ILX</a> is incorporated into it).</li>
<li>DotNet have been designed to run mainly OO staticly typed language (such as C#).</li>
<li>DotNet is heavyweighted for small applications.</li>
<li>DotNet is not Open Source.</li>
<li>DotNet bytecode have a high learning curve and it is not easy to generate to it.</li>
</ul>

<p>
Some other alternatives are available, but they're either too much low-level (<a href="http://llvm.cs.uiuc.edu">LLVM</a>) or dedicated to dynamicly typed languages  (<a href="http://www.parrotcode.org">Parrot</a>). As a <a href="http://ncannasse.free.fr/index.php?p=19">language designer</a> and <a href="http://www.mtasc.org">compiler writer</a>, I have my own way of thinking about multilanguage framework with code reusability, so I decided to give it a try.
</p>


<h2>Syntax</h2>

<p>
Neko language syntax have been created with "easy to parse" and "easy to generate" in mind. It is not especially designed to be written by a programmer but more to be generated from a higher level language. For example one could write easily a PHP-to-Neko or a Java-to-Neko that would generate equivalent code but using Neko syntax and semantics instead of PHP or Java ones.
</p>

<p>
In particular, there are not multiple levels of expression, as in C. Every statement is also an expression, and thus enable some constructs that are not possible in other languages (for example : <code>return if(x) { ... } else { ... }</code>). This make the generation to Neko from functional languages more easy.
</p>

<p>
The syntax is parsed using a left-to-right LL(1) parser. That means that after reading a token we have enough information to know which expresion it will produce. This enable very lightweight parser which is easy to improve without creating ambiguities. Here's an Abstract Syntax Tree description of the language syntax, with the additionnal constraint that a program must be terminated by EOF :
</p>

<pre>
	    <i>program</i> :=
		| <i>expr</i> <i>program</i>
		| <b>SEMICOLON</b> <i>program</i>
		| &epsilon;

	    <i>ident</i> :=
		| [a-zA-Z_@] [a-zA-Z0-9_@:]*

	    <i>binop</i> :=
		| [!=*/&lt;&gt;&|^%+:-]+

	    <i>value</i> :=
		| [0-9]+
		| 0x[0-9A-Fa-f]+
		| [0-9]+ <b>DOT</b> [0-9]*
		| <b>DOT</b> [0-9]+
		| <b>DOUBLEQUOTE</b> <i>characters</i> <b>DOUBLEQUOTE</b>
		| <b>DOLLAR</b> <i>ident</i>
		| <b>SHARP</b> <i>ident</i>
		| <b>QUOTE</b> <i>ident</i>
		| <b>true</b>
		| <b>false</b>
		| <b>null</b>
		| <b>this</b>
		| <i>ident</i>

	    <i>expr</i> :=
		| <i>value</i>
		| <b>{</b> <i>program</i> <b>}</b>
		| <i>expr</i> <b>DOT</b> <i>ident</i>
		| <i>expr</i> <b>(</b> <i>parameters</i> <b>)</b>
		| <i>expr</i> <b>[</b> <i>expr</i> <b>]</b>
		| <i>expr</i> <i>binop</i> <i>expr</i>
		| <b>(</b> <i>expr</i> <b>)</b>
		| <b>var</b> <i>variables</i>
		| <b>for (</b> <i>expr</i> <i>expr</i> <i>expr</i> <b>)</b> <i>expr</i>
		| <b>while</b> <i>expr</i> <i>expr</i>
		| <b>do</b> <i>expr</i> <b>while</b> <i>expr</i>
		| <b>if</b> <i>expr</i> <i>expr</i> [<b>else</b> <i>expr</i>]
		| <b>try</b> <i>expr</i> <b>catch</b> <i>ident</i> <i>expr</i>
		| <b>function (</b> <i>parameters-names</i> <b>)</b> <i>expr</i>
		| <b>return</b> [<i>expr</i> | <b>SEMICOLON</b>]
		| <b>break</b> [<i>expr</i> | <b>SEMICOLON</b>]
		| <b>continue</b>

	    <i>variables</i> :=
		| <i>ident</i> [<b>=</b> <i>expr</i>] <i>variables</i>
		| <b>COMMA</b> <i>variables</i>
		| &epsilon;

	    <i>parameters</i> :=
		| <i>expr</i> <i>parameters</i>
		| <b>COMMA</b> <i>parameters</i>
		| &epsilon;

	    <i>parameters-names</i> :=
		| <i>ident</i> <i>parameters-names</i>
		| <b>COMMA</b> <i>parameters-names</i>
		| &epsilon;

	    <i>cases</i> :=
		| <i>expr</i> <b>=></b> <i>expr</i> <i>cases</i>
		| <b>default</b> <b>=></b> <i>expr</i> <i>cases</i>
		| &epsilon;

</pre>

<p>
	<i>Random notes : </i>
</p>

<ul>
<li><code>continue</code> behavior in a <code>for</code> increments part (third expression) is undefined.</li>
<li><code>continue</code> and <code>break</code> outside a loop are not specified.</li>
<li><code>return</code> in the toplevel (outside a function) is an accepted way of interupting module execution without error.</li>
<li>There are some few ambiguous cases when two expressions follows each others (in for, while and if). If the second expression is inside parenthesis, it will be parsed as a call of first expression, while such a representation e1 (e2) exists in the AST (the semicolons are optional).</li>
</ul>

<h2>Values</h2>

<p>
A value in Neko can be one of the following :
</p>

<ul>
<li><b>Integer :</b> integers can be represented in either decimal form (such as <code>12345</code> or <code>-12</code>) or hexadecimal (<code>0x1A2B3C4D</code>).</li>
<li><b>Floating point :</b> floating point values are represented using a dot (such as <code>12.345</code> or <code>-0.123</code>)</li>
<li><b>String :</b> strings are double quoted (such as <code>"foo"</code>, or <code>"hello,\nworld !"</code>, or <code>"My name is \"Bond\\James Bond\"."</code>). Neko strings are immutable, that means that you cannot modify them.</li>
<li><b>Boolean :</b> the two booleans are available as specific lowercased identifiers : <code>true</code> and <code>false</code>.</li>
<li><b>Null :</b> the special value <code>null</code> is used for uninitialized variables as well as programmer/langage specific coding techniques.</li>
<li><b>Object :</b> an object is an association table, which bind an ident or a string to a value, see how you can create and manage objects later.</li>
<li><b>Array :</b> arrays are indexed table of values, starting at index 0, they provide fast random access.</li>
<li><b>Function :</b> a function is also a value in Neko, and can then be stored into any variable.</li>
</ul>

<p>
Some precisions :
</p>

<ul>
<li>integers are 31 bits for virtual machine performances reasons, an access to full 32 bits integers will be made possible soon.</li>
<li>floating points are 64 bits double precision floating points values.</li>
<li>strings are 8-bit binary values. A string can contain \0 characters, the string length is determined by the amount of data available and not by the number of characters before the first \0. Maximum string size might depend of virtual machine specification, but should be at least 65535 bytes.</i>
</ul>

<h2>Execution Flow</h2>

<p>
Here's some explanation on how each expression is evaluated :
</p>

<h3>
Values :
</h3>

<ul>
<li><code>[0-9]+ | 0x[0-9A-Fa-f]+</code> : evaluate to the corresponding integer value</li>
<li><code>[0-9]+ <b>DOT</b> [0-9]* | <b>DOT</b> [0-9]+</code> : evaluate to the corresponding floating point value</code></li>
<li><code><b>DOUBLEQUOTE</b> <i>characters</i> <b>DOUBLEQUOTE</b></code> : evaluate to the corresponding string. Escaped characters are simular to the C language.</li>
<li><code><b>DOLLAR</b> <i>ident</i></code> : identifiers prefixed with a dollar are primitives. They enable you to call some compiler constructors or optimized calls (see Primitives).</li>
<li><code><b>SHARP</b> <i>ident</i></code> : identifiers prefixed with a sharp are modules. See later for explanations of module loading and linking (see Modules).</li>
<li><code><b>QUOTE</b> <i>ident</i></code> : execute a macro at parsing-time (see Macros)</li>
<li><code><b>true</b> | <b>false</b></code> : evaluate to the corresponding boolean.</li>
<li><code><b>null</b></code> : evaluate to the null value.</li>
<li><code><b>this</b></code> : evaluate to the local object value (see later for objects).</li>
<li><code><i>ident</i></code> : evaluate to the value currently bound to this variable name.</li>
</ul>

<h3>Expressions</h3>
<p>
<em>before evaluating any expression, all sub-expressions are evaluated in an unspecified order. the "v" here are showing the values returned by evaluation of sub-expressions.</em>
</p>

<ul>
<li><code><b>{</b> <i>v1, v2, .... vk</i> <b>}</b></code> : the evaluation order is specified here, it follows the expressions declarations. The last value <code>vk</code> is returned, or <code>null</code> if <code>program</code> does not contain any expression.</li>
<li><code><i>v</i> <b>DOT</b> <i>ident</i></code> : <code>v</code> is accessed as an object using <code>ident</code> as key (see Objects).</li>
<li><code><i>v</i> <b>(</b> <i>v1, v2, ... vk</i> <b>)</b></code> : the function <code>v</code> is called with the parameters <code>v1, v2... vk</code> (see Function Calls)</li>
<li><code><i>v1</i> <b>[</b> <i>v2</i> <b>]</b></code> : <code>v1</code> is accessed as an array using <code>v2</code> as key (see Arrays)</li>
<li><code><i>v1</i> <i>binop</i> <i>v2</i></code> : calculate v1 op v2 (see Operations).</li>
<li><code><i>expr</i> <i>assign-binop</i> <i>v</i></code> : this is a special case, when operation is an assignation (see Operations).</li>
<li><code><b>(</b> <i>v</i> <b>)</b></code> : evaluate to <code>v</code>.</li>
<li><code><b>var</b> <i>i1 = v1, i2 = v2, .... ik = vk</i></code> : each variable <code>i</code> is set to the corresponding value <code>v</code> or to <code>null</code> if no initialization expression is provided.</li>
<li><code><b>for</b>...</code> : classic for-loop, the value returned is either the value returned by a <code>break</code> inside the for or unspecified.</li>
<li><code><b>while</b> ....  | <b>do</b> ... <b>while</b> ...</code> : classic while-loop, same as for.</li>
<li><code><b>if</b> <i>v1</i> <i>e1</i></code> : if v1 is the Boolean <code>true</code>, then <code>e1</code> is evaluated and its value returned, else the evaluated value is unspecified.</li>
<li><code><b>if</b> <i>v1</i> <i>e1</i> <b>else</b> <i>e2</i></code> : if v1 is the Boolean <code>true</code>, then <code>e1</code> is evaluated and its value returned else <code>e2</code> is evaluated and its value returned.</li>
<li><code><b>try</b> <i>e1</i> <b>catch</b> <i>i</i> <i>e2</i></code> : evaluate <code>e1</code> and returns the evaluated value. If an exception is raised, then evaluate <code>e2</code> and returns evaluated value with local <code>i</code> variable being set to the raised exception value (see Exceptions).</li>
<li><code><b>function (</b> <i>parameters-names</i> <b>)</b> <i>expr</i></code> : evaluate to the corresponding function.</li>
<li><code><b>return</b>;</code> : exit current function with unspecified return value.</li>
<li><code><b>return</b> v</code> : exit current function and return value <code>v</code>.</li>
<li><code><b>break</b>;</code> : exit current for or while loop with unspecified return value.</li>
<li><code><b>break</b> v</code> : exit current for or while loop and return value <code>v</code>.</li>
<li><code><b>continue</b></code> : continue execution to next while/for loop step.</li>
</ul>

<h2>Variables</h2>

<p>
When an identifier is found, it must be resolved to a given context holding the variable value. The first context searched for is the local context.
</p>

<h3>Local Context</h3>

<p>
The local context contains all variable defined with the "var" keyword in previous syntaxical blocks. In the following sample, <code>x</code> resolve to the value 3 :
</p>

<pre>
	var x = 3;
	$print(x);
</pre>

<p>
A "var" declaration is only local to the curly-braced block it has been declared in. For example :
</p>

<pre>
	var x = 3;
	// x defined
	if( ... ) {
		// x defined
		var y;
		// x and y defined;
	}
	// x defined
</pre>

<p>
Same variable name can be reused in same block or in another block. It will hide or erase previous value :
</p>

<pre>
	var x = 1;
	$print(x); // print 1
	var x = 3;
	$print(x); // print 3
	if( ... ) {
		var x = "neko";
		$print(x); // print "neko"
	}
	$print(x); // print 3
</pre>

<p>
Function parameters are also local variables, they are defined into the whole function :
</p>

<pre>
	var x = 3;
	f = function(x) {
		$print(x);
	}
	f("neko"); // print "neko"
</pre>

<p>
Since contexts are resolved at purely syntactic level, local variables does not depends on current call-stack, and you cannot access variables defined outside current local context.
</p>

<pre>
	f = function() {
		$print(x);
	}
	...
	var x = 3;
	f(); // null or error !
</pre>

<h3>Function Environment</h3>

<p>
Local variables can be used inside functions if they're accessible at the time the function is declared. In this case, the value of the variable is a copy of the value it had at the time the function was defined :
</p>

<pre>
	var x = 3;
	f = function() {
		$print(x);
	}
	x = 4;
	f(); // print 3
</pre>

<p>
Such variables are called environment variables because they're no longer part of the local context but of the function "environment" context. A function can still modify an environment variable but this will not modify the original variable reference :
</p>

<pre>
	var x = 3;
	f = function() {
		$print(x);
		x += 1;
	}
	x = 50;
	f(); // print 3
	f(); // print 4
	$print(x); // print 50
</pre>

<p>
Please note also that each function instance have its own environment :
</p>

<pre>
	gen = function() {
		var i = 0;
		return function() { $print(i); i += 1; };
	}
	f1 = gen();
	f2 = gen();
	f1(); // print 0
	f1(); // print 1
	f2(); // print 0
	f1(); // print 2
	...
</pre>

<h3>Global Context</h3>

<p>
When a variable is not found in the local context or in the local function environment, it is a global. A global can be accessed through the whole file, it is shared among all code.
</p>

<pre>
	f = function() {
		$print(x);
		x += 1;
	}
	x = 0;
	f(); // print 0
	f(); // print 1
	$print(x); // print 2
</pre>

<p>
It might be useful to add primitives that can direclty access the global context.
</p>

<h2>Function & Function Calls</h2>

<p>
Defining new functions is easy, since functions are values, you can simply assign them to a local or a global variable :
</p>

<pre>
	var foo = function() {
		return 0;
	}
</pre>

<p>
	Functions are called by-value, that means that <code>foo(1)</code> calls the function which is the value of the variable foo. Calling a value that is not a function or that does not accept this number of arguments returns a <code>null</code> value. You can use the <code>$isfun</code> primitive to add a runtime check that will raise an exception if the value is not a function or if the number of arguments is not correct, and that will simply returns the function either :
</p>

<pre>
	var foo = 3;
	foo(); // null
	$isfun(foo,0); // exception

	var foo = function() { return 0; };
	foo(3); // null
	$isfun(foo,1)(3); // exception
	$isfun(foo,0)(); // ok
</pre>

<p>
	A function call is successful only if the value is a function and is called with the exact number of arguments needed. In you need optional arguments, you can use the primitive <code>$callopt</code> that will call the function, adding <code>null</code> arguments if missing and ignoring additional arguments :
</p>

<pre>
	var foo = function(x,y) { $print(x+y) };
	foo(3); // null
	$callopt(foo,3); // call foo(3,null) : prints "null"
	$callopt(foo,3,4,5); // call foo(3,4) : prints "7"
	$callopt(null); // null
</pre>


<p>
	You can know the number of arguments needed by a function by using the primitive <code>$nargs</code>. A function that accepts a variable number of arguments returns -1 when used with <code>$nargs</code>. Please note also that primitives can be used as values :
</p>

<pre>
	$print($nargs(function(a,b) { return a + b; }); // prints 2
	$print($nargs($callopt)); // prints -1
	$print($nargs(0)); // prints null

	$isfun($callopt,3); // ok, since we can call $callopt with 3 arguments
</pre>

<p>
	<em>Note :It might be useful to provide syntax so the user can define its own variable arguments functions.</em>
</p>

<p>
	There is one other way of calling a function : primitive <code>$call</code> takes an array of arguments and a object context (see Objects section) as parameters. This primitive can be useful for introspection :
</p>

<pre>
	$call(foo,null,$array(3,4)); // call the foo function with null context and two parameters 3 and 4
</pre>

<p>
	Some languages might want more security about the types of the arguments that are passed to a function, or selecting at runtime different implementations of a function depending on the type of the arguments. There are many ways of doing that in Neko. For example, you might want to add arguments checks at the beginning of the function body using runtime types informations (RTTI) primitives.
</p>

<h2>Macros</h2>

<p>
When you want to generate from another language to Neko, you might need some syntactic shortcuts for operations that are often used. For example let's imagine a language where the empty string evaluate to <code>false</code>, that means that in Neko for each test (if, while...) you will have to test for <code>false</code> and for the empty string. Macros enable you to do that easily :
</p>

<pre>
	is_true = function(x) {
		x && x != ""
	}
	...
	if( 'is_true(<em>expr</em>) )
		...
</pre>

<p>
As you noticed, macro are function which are called with an preceding quote, that means that the macro will be expanded before even starting execution, so you will not call function is_true actually, but replace its contents by the corresponding expression. Let's see how it works :
</p>

<pre>
	if( 'is_true(33) )
</pre>

<p>
Will be turned into :
</p>

<pre>
	if( { 33 && 33 != "" } )
</pre>

<p>
Please note that the last syntactic assignment of "is_true" is used as macro. That means that macros generation are not done at runtime and that the value of <code>is_true</code> at the time the <code>if</code> is evaluated will not change anything. Another thing, is that you have to be careful about macros, since in previous case 33 is evaluated twice, macro expansion can break some code :
</p>

<pre>
	if( 'is_true(f(x)) )
</pre>

<p>
Expands to :
</p>

<pre>
	if( { f(x) && f(x) != "" } )
</pre>

<p>
Which is wrong, since we don't want to evaluate twice the expression, or call twice the function in this case. We need then to redefine the macro is_true this way :
</p>

<pre>
	is_true = function(x) {
		var tmp = x;
		tmp && tmp != ""
	}
</pre>

<p>
Now previous case correctly expands to :
</p>

<pre>
	if( { var tmp = f(x); tmp && tmp != "" } )
</pre>

<p>
Please note that macros can't really define new variables since every macro expansion will be enclosed into curly braced block that will prevent them from escaping the scope.
</p>

<p>
In such case, the naming of the variable <code>tmp</code> is not important, since we're evaluating f(x) before adding it to the scope, it can't then hide or replace an user define variable. But in some more complex macros that can be the case. Macro locals variables have then to be carefuly chosen. (<em>or maybe the Neko macro expander should rename macros local variables with unique name, which will guarantee that they will not break</em>).
</p>

<h2>Operations</h2>

<p>
The following operations are defined. The notation is the following <code>+ : t1 -> t2 -> t3</code> means that the operation "+" is defined for being applied on two values v1 of type t1 and v2 of type t2 and will return a value v3 of type t3 as result.
</p>

<ul>
<li>+ : int -> int -> int  , add two integers</li>
<li>+ : int -> float -> float | + : float -> int -> float : add one integer and one float</li>
<li>+ : float -> float -> float : add two floats</li>
<li>+ : int -> string -> string | float -> string -> string | string -> int -> string | string -> float -> string : concat the string representation of integer or float with string</li>
<li>+ : string -> string -> string : concat two strings</li>
<li>- : int -> int -> int , substract two integers</li>
<li>- : float -> int -> float | int -> float -> float , substract one integer and one float</li>
<li>- : float -> float -> float : subtract two floats</li>
<li>*, % and / are like minus operation</li>
<li>....</li>
</ul>

<p>
TODO : finish, unary operation, assign-binops, optimized primitives for integers/floats ?
</p>

<p>
-- TODO --
</p>

<ul>
<li>Objects : (access, r/w, this, exceptions on access)</li>
<li>Arrays : (exceptions on bounds, primitives)</li>
<li>Strings : primitives</li>
<li>Numbers : primitives</li>
<li>Operations : (conversion, exceptions, assignations, unaires : - , ! )</li>
<li>Primitives, optimizations, accés C, $print $callfun $callopt $throw</li>
<li>Modules</li>
<li>Exceptions : handlers</li>
<li>Hashtbls : dans le language ?</li>
</ul>

<i>(c)2004-2005 Nicolas Cannasse</i>

</body>
</html>
