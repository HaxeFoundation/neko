
<h1>Neko Language Specification</h1>

<!-- ****************************************************************************** -->

<a name="summary"></a>
<h2>Summary</h2>

<ul>
	<li><a href="#syntax">Syntax</a></li>
	<li><a href="#values">Values</a></li>
	<li><a href="#execution">Execution Flow</a></li>
	<li><a href="#variables">Variables</a></li>
	<li><a href="#operations">Basic Type Operations</a>
		<ul>
			<li><a href="#arithm">Arithmetic Operations</a></li>
			<li><a href="#bitwise">Bitwise Operations</a></li>
			<li><a href="#boolops">Boolean Operations</a></li>
			<li><a href="#compares">Equality and Comparisons</a></li>
			<li><a href="#assigns">Assigns</a></li>
			<li><a href="#converts">Conversions</a></li>
			<li><a href="#optim">Optimized Operations</a></li>
		</ul>
	</li>
	<li><a href="#rtti">Runtime Type Information</a></li>
	<li><a href="#functions">Functions and Function Calls</a></li>
	<li><a href="#objects">Objects</a></li>
	<li><a href="#arrays">Arrays</a></li>
	<li><a href="#strings">Strings</a></li>
	<li><a href="#exceptions">Exceptions</a></li>
	<li><a href="#hash">Hashtables</a></li>
	<li><a href="#labels">Labels and Gotos</a></li>
</ul>

<!-- ****************************************************************************** -->

<a name="syntax"></a>
<h2>Syntax</h2>

<p>
Neko language syntax have been created with "easy to parse" and "easy to generate" in mind. It is not especially designed to be written by a programmer but more to be generated from a higher level language. For example one could write easily a PHP-to-Neko or a Java-to-Neko that would generate equivalent code but using Neko syntax and semantics instead of PHP or Java ones.
</p>

<p>
In particular, there are not multiple levels of expression, as in C. Every statement is also an expression, and thus enable some constructs that are not possible in other languages (for example : <code>return if(x) { ... } else { ... }</code>). This make the generation to Neko from functional languages more easy.
</p>

<p>
The syntax is parsed using a left-to-right LL(1) parser. That means that after reading a token we have enough information to know which expresion it will produce. This enable very lightweight parser which is easy to improve without creating ambiguities. Here's an Abstract Syntax Tree description of the language syntax, with the additionnal constraint that a program must be terminated by EOF :
</p>

<pre>
	    <i>program</i> :=
		| <i>expr</i> <i>program</i>
		| <b>SEMICOLON</b> <i>program</i>
		| &epsilon;

	    <i>ident</i> :=
		| [a-zA-Z_@] [a-zA-Z0-9_@]*

	    <i>binop</i> :=
		| [!=*/&lt;&gt;&amp;|^%+:-]+

	    <i>value</i> :=
		| [0-9]+
		| 0x[0-9A-Fa-f]+
		| [0-9]+ <b>DOT</b> [0-9]*
		| <b>DOT</b> [0-9]+
		| <b>DOUBLEQUOTE</b> <i>characters</i> <b>DOUBLEQUOTE</b>
		| <b>DOLLAR</b> <i>ident</i>
		| <b>true</b>
		| <b>false</b>
		| <b>null</b>
		| <b>this</b>
		| <i>ident</i>

	    <i>expr</i> :=
		| <i>value</i>
		| <b>{</b> <i>program</i> <b>}</b>
		| <b>{</b> <i>ident1</i> <b>=></b> <i>expr1</i> <b>,</b> <i>ident2</i> <b>=></b> <i>expr2</i> <b>...</b> <b>}</b>
		| <i>expr</i> <b>DOT</b> <i>ident</i>
		| <i>expr</i> <b>(</b> <i>parameters</i> <b>)</b>
		| <i>expr</i> <b>[</b> <i>expr</i> <b>]</b>
		| <i>expr</i> <i>binop</i> <i>expr</i>
		| <b>(</b> <i>expr</i> <b>)</b>
		| <b>var</b> <i>variables</i>
		| <b>while</b> <i>expr</i> <i>expr</i>
		| <b>do</b> <i>expr</i> <b>while</b> <i>expr</i>
		| <b>if</b> <i>expr</i> <i>expr</i> [<b>else</b> <i>expr</i>]
		| <b>try</b> <i>expr</i> <b>catch</b> <i>ident</i> <i>expr</i>
		| <b>function (</b> <i>parameters-names</i> <b>)</b> <i>expr</i>
		| <b>return</b> [<i>expr</i> | <b>SEMICOLON</b>]
		| <b>break</b> [<i>expr</i> | <b>SEMICOLON</b>]
		| <b>continue</b>
		| <i>ident</i> <b>:</b>
		| <b>switch</b> <i>expr</i> <b>{</b> <i>switch-case</i>* <b>}</b>

	    <i>variables</i> :=
		| <i>ident</i> [<b>=</b> <i>expr</i>] <i>variables</i>
		| <b>COMMA</b> <i>variables</i>
		| &epsilon;

	    <i>parameters</i> :=
		| <i>expr</i> <i>parameters</i>
		| <b>COMMA</b> <i>parameters</i>
		| &epsilon;

	    <i>parameters-names</i> :=
		| <i>ident</i> <i>parameters-names</i>
		| <b>COMMA</b> <i>parameters-names</i>
		| &epsilon;

	    <i>switch-cases</i> :=
		| <b>default =></b> <i>expr</i>
		| <i>ident</i> <b>=></b> <i>expr</i>

</pre>

<p>
	<i>Random notes : </i>
</p>

<ul>
<li><code>continue</code> and <code>break</code> outside a while are not allowed.</li>
<li>There are some few ambiguous cases when two expressions follows each others (in while and if). If the second expression is inside parenthesis, it will be parsed as a call of first expression, while such a representation e1 (e2) exists in the AST (the semicolons are optional).</li>
</ul>

<!-- ****************************************************************************** -->

<a name="values"></a>
<h2>Values</h2>

<p>
A value in Neko can be one of the following :
</p>

<ul>
<li><b>Null :</b> the special value <code>null</code> is used for uninitialized variables as well as programmer/langage specific coding techniques.</li>
<li><b>Integer :</b> integers can be represented in either decimal form (such as <code>12345</code> or <code>-12</code>) or hexadecimal (<code>0x1A2B3C4D</code>).</li>
<li><b>Floating point :</b> floating point values are represented using a dot (such as <code>12.345</code> or <code>-0.123</code>)</li>
<li><b>Boolean :</b> the two booleans are available as specific lowercased identifiers : <code>true</code> and <code>false</code>.</li>
<li><a href="#strings"><b>String</b></a> : strings are double quoted (such as <code>"foo"</code>, or <code>"hello,\nworld !"</code>, or <code>"My name is \"Bond\\James Bond\"."</code>). Neko strings are mutable, that means that you can modify them.</li>
<li><a href="#arrays"><b>Array</b></a> : arrays are indexed table of values, starting at index 0, they provide fast random access.</li>
<li><a href="#objects"><b>Object</b></a> : an object is an association table, which bind an ident or a string to a value, see how you can create and manage objects later.</li>
<li><a href="#functions"><b>Function</b></a> : a function is also a value in Neko, and can then be stored into any variable.</li>
<li><b>Abstract</b> : an abstract value is some C data that cannot be accessed from a Neko program.</li>
</ul>

<p>
Some precisions :
</p>

<ul>
<li>integers are 31 bits for virtual machine performances reasons, an api for full 32 bits integers can be made using C libraries.</li>
<li>floating points are 64 bits double precision floating points values.</li>
<li>strings are 8-bit binary values. A string can contain \0 characters, the string length is determined by the amount of data available and not by the number of characters before the first \0.</li>
</ul>

<!-- ****************************************************************************** -->

<a name="execution"></a>
<h2>Execution Flow</h2>

<p>
Here's some explanation on how each expression is evaluated :
</p>

<h3>
Values :
</h3>

<ul>
<li><code>[0-9]+ | 0x[0-9A-Fa-f]+</code> : evaluate to the corresponding integer value</li>
<li><code>[0-9]+ <b>DOT</b> [0-9]* | <b>DOT</b> [0-9]+</code> : evaluate to the corresponding floating point value.</li>
<li><code><b>DOUBLEQUOTE</b> <i>characters</i> <b>DOUBLEQUOTE</b></code> : evaluate to the corresponding string. Escaped characters are simular to the C language.</li>
<li><code><b>DOLLAR</b> <i>ident</i></code> : identifiers prefixed with a dollar are builtins. They enable you to call some compiler constructors or optimized calls.</li>
<li><code><b>true</b> | <b>false</b></code> : evaluate to the corresponding boolean.</li>
<li><code><b>null</b></code> : evaluate to the null value.</li>
<li><code><b>this</b></code> : evaluate to the local object value (see later for objects).</li>
<li><code><i>ident</i></code> : evaluate to the value currently bound to this variable name.</li>
</ul>

<h3>Expressions</h3>
<p>
Before evaluating any expression, all sub-expressions are evaluated in an unspecified order. the "v" here are showing the values returned by evaluation of sub-expressions.
</p>

<ul>
<li><code><b>{</b> <i>v1; v2; .... vk</i> <b>}</b></code> : the evaluation order is specified here, it follows the expressions declarations. The last value <code>vk</code> is returned, or <code>null</code> if <code>program</code> does not contain any expression.</li>
<li><code><b>{</b> <i>i1</i> <b>=></b> <i>v1</i> <b>,</b> <i>i2</i> <b>=></b> <i>v2</i> <b>...</b> <b>}</b></code> : this will create an object with fields <i>i1...ik</i> set to values <i>v1...vk</i>. It might be more optimized than setting the fields one-by-one on an empty object.</li>
<li><code><i>v</i> <b>DOT</b> <i>ident</i></code> : <code>v</code> is accessed as an object using <code>ident</code> as key (see Objects).</li>
<li><code><i>v</i> <b>(</b> <i>v1, v2, ... vk</i> <b>)</b></code> : the function <code>v</code> is called with the parameters <code>v1, v2... vk</code> (see Function Calls)</li>
<li><code><i>v1</i> <b>[</b> <i>v2</i> <b>]</b></code> : <code>v1</code> is accessed as an array using <code>v2</code> as key (see Arrays)</li>
<li><code><i>v1</i> <i>binop</i> <i>v2</i></code> : calculate v1 op v2 (see Operations).</li>
<li><code><i>expr</i> <b>=</b> <i>v</i></code> : this is a special case, when operation is an assignation (see Operations).</li>
<li><code><b>(</b> <i>v</i> <b>)</b></code> : evaluate to <code>v</code>.</li>
<li><code><b>var</b> <i>i1 = v1, i2 = v2, .... ik = vk</i></code> : each variable <code>i</code> is set to the corresponding value <code>v</code> or to <code>null</code> if no initialization expression is provided.</li>
<li><code><b>while</b> ....  | <b>do</b> ... <b>while</b> ...</code> : classic while-loop, the value returned is either the value returned by a <code>break</code> inside the while or unspecified if the loop ends without break.</li>
<li><code><b>if</b> <i>v1</i> <i>e1</i></code> : if v1 is the boolean <code>true</code>, then <code>e1</code> is evaluated and its value returned, else the evaluated value is unspecified.</li>
<li><code><b>if</b> <i>v1</i> <i>e1</i> <b>else</b> <i>e2</i></code> : if v1 is the boolean <code>true</code>, then <code>e1</code> is evaluated and its value returned else <code>e2</code> is evaluated and its value returned.</li>
<li><code><b>try</b> <i>e1</i> <b>catch</b> <i>i</i> <i>e2</i></code> : evaluate <code>e1</code> and returns the evaluated value. If an exception is raised, then evaluate <code>e2</code> and returns evaluated value with local <code>i</code> variable being set to the raised exception value (see Exceptions).</li>
<li><code><b>function (</b> <i>parameters-names</i> <b>)</b> <i>expr</i></code> : evaluate to the corresponding function.</li>
<li><code><b>return</b>;</code> : exit current function with unspecified return value.</li>
<li><code><b>return</b> v</code> : exit current function and return value <code>v</code>.</li>
<li><code><b>break</b>;</code> : exit current while loop with unspecified return value.</li>
<li><code><b>break</b> v</code> : exit current while loop and return value <code>v</code>.</li>
<li><code><b>continue</b></code> : continue execution to next while loop step.</li>
<li><code><i>ident</i>:</code> : a label, see the corresponding section.</li>
<li><code><b>switch</b> <i>e</i> <b>{</b> <i>e1a</i> <b>=></b> <i>e1b</i> <i>e2a</i> <b>=></b> <i>e2b</i> .... <b>default =></b> <i>edef</i> <b>}</b></code> : evaluate e and test it with each <code>e<i>i</i>a</code> sequentially until it is equal, then return the corresponding expression <code>e<i>i</i>b</code> evaluated. If no equal value is found, the <code>edef</code> expression is evaluated, which is <code>null</code> if no <code>default</code> specified.</li>
</ul>

<p>
	Please note that <code>if</code> and <code>while</code> conditions only sucess for the boolean <code>true</code> and for no other value. You might need to add a <code>$istrue</code> code before each expression in order to convert the expression result into a boolean.
</p>

<!-- ****************************************************************************** -->

<a name="variables"></a>
<h2>Variables</h2>

<p>
When an identifier is found, it must be resolved to a given context holding the variable value. The first context searched for is the local context.
</p>

<h3>Local Context</h3>

<p>
The local context contains all variable defined with the "var" keyword in previous syntaxical blocks. In the following sample, <code>x</code> resolve to the value 3 :
</p>

<pre>
	var x = 3;
	$print(x);
</pre>

<p>
A "var" declaration is only local to the curly-braced block it has been declared in. For example :
</p>

<pre>
	var x = 3;
	// x defined
	if( ... ) {
		// x defined
		var y;
		// x and y defined;
	}
	// x defined
</pre>

<p>
Same variable name can be reused in same block or in another block. It will hide or erase previous value :
</p>

<pre>
	var x = 1;
	$print(x); // print 1
	var x = 3;
	$print(x); // print 3
	if( ... ) {
		var x = "neko";
		$print(x); // print "neko"
	}
	$print(x); // print 3
</pre>

<p>
Function parameters are also local variables, they are defined into the whole function :
</p>

<pre>
	var x = 3;
	f = function(x) {
		$print(x);
	}
	f("neko"); // print "neko"
</pre>

<p>
Since contexts are resolved at purely syntactic level, local variables does not depends on current call-stack, and you cannot access variables defined outside current local context.
</p>

<pre>
	f = function() {
		$print(x);
	}
	...
	var x = 3;
	f(); // will print "null"
</pre>

<h3>Function Environment</h3>

<p>
Local variables can be used inside functions if they're accessible at the time the function is declared. In this case, the value of the variable is a copy of its value at the time the function was defined :
</p>

<pre>
	var x = 3;
	f = function() {
		$print(x);
	}
	x = 4;
	f(); // print 3
</pre>

<p>
Such variables are called environment variables because they're no longer part of the local context but of the function "environment" context. A function can still modify an environment variable but this will not modify the original variable reference :
</p>

<pre>
	var x = 3;
	f = function() {
		$print(x);
		x = x + 1;
	}
	x = 50;
	f(); // print 3
	f(); // print 4
	$print(x); // print 50
</pre>

<p>
Please note also that each function instance have its own environment :
</p>

<pre>
	gen = function() {
		var i = 0;
		return function() { $print(i); i = i + 1; };
	}
	f1 = gen();
	f2 = gen();
	f1(); // print 0
	f1(); // print 1
	f2(); // print 0
	f1(); // print 2
	...
</pre>

<h3>Global Context</h3>

<p>
When a variable is not found in the local context or in the local function environment, it is a global. A global can be accessed through the whole file, it is shared among all code.
</p>

<pre>
	f = function() {
		$print(x);
		x = x + 1;
	}
	x = 0;
	f(); // print 0
	f(); // print 1
	$print(x); // print 2
</pre>

<!-- ****************************************************************************** -->

<a name="operations"></a>
<h2>Basic Types Operations</h2>

<p>
Basic types are numbers (int and float), booleans (bool), the null value, strings, objects, arrays and functions. There are several operations available to use them, see the following tables. On the row is first operand type and on the columns is second operand type. The result is either the type of the returned value, or "concat" if we use string concatenation (in that case the two values are converted to strings and then concatened together). The "-" means that the operation is invalid and will raise an exception.
</p>

<a name="arithm"></a>
<h3>Arithmetic operations</h3>

<p>
Operation add ( + ) :
</p>

<table>
<tr>
	<th> + </th>
	<th>null</th>
	<th>int</th>
	<th>float</th>
	<th>string</th>
	<th>bool</th>
	<th>object</th>
	<th>array</th>
	<th>function</th>
</tr>
<tr>
	<th>null</th>
	<td>-</td>
	<td>-</td>
	<td>-</td>
	<td>concat</td>
	<td>-</td>
	<td>__radd</td>
	<td>-</td>
	<td>-</td>
</tr>
<tr>
	<th>int</th>
	<td>-</td>
	<td>int</td>
	<td>float</td>
	<td>concat</td>
	<td>-</td>
	<td>__radd</td>
	<td>-</td>
	<td>-</td>
</tr>
<tr>
	<th>float</th>
	<td>-</td>
	<td>float</td>
	<td>float</td>
	<td>concat</td>
	<td>-</td>
	<td>__radd</td>
	<td>-</td>
	<td>-</td>
</tr>
<tr>
	<th>string</th>
	<td>concat</td>
	<td>concat</td>
	<td>concat</td>
	<td>concat</td>
	<td>concat</td>
	<td>__radd</td>
	<td>concat</td>
	<td>concat</td>
</tr>
<tr>
	<th>bool</th>
	<td>-</td>
	<td>-</td>
	<td>-</td>
	<td>concat</td>
	<td>-</td>
	<td>__radd</td>
	<td>-</td>
	<td>-</td>
</tr>
<tr>
	<th>object</th>
	<td>__add</td>
	<td>__add</td>
	<td>__add</td>
	<td>__add</td>
	<td>__add</td>
	<td>__add</td>
	<td>__add</td>
	<td>__add</td>
</tr>
<tr>
	<th>array</th>
	<td>-</td>
	<td>-</td>
	<td>-</td>
	<td>concat</td>
	<td>-</td>
	<td>__radd</td>
	<td>-</td>
	<td>-</td>
</tr>
<tr>
	<th>function</th>
	<td>-</td>
	<td>-</td>
	<td>-</td>
	<td>concat</td>
	<td>-</td>
	<td>__radd</td>
	<td>-</td>
	<td>-</td>
</tr>
</table>

<p>
	Addition can be overridden for objects : <code>a + b</code> will call <code>a.__add(b)</code> if <code>a</code> is an object, or <code>b.__radd(a)</code> if <code>b</code> is an object.
</p>

<p>
Operations substract ( - ) divide ( / ) multiply ( * ) and modulo ( % ) :
</p>


<table>
<tr>
	<th> - / * % </th>
	<th>int</th>
	<th>float</th>
</tr>
<tr>
	<th>int</th>
	<td>int (float for /)</td>
	<td>float</td>
</tr>
<tr>
	<th>float</th>
	<td>float</td>
	<td>float</td>
</tr>
</table>

<p>
	Please note that unlike some languages, the divide operation between two integers does returns a float. You can use the <code>$idiv</code> builtin that performs integer division.
</p>

<p>
	Dividing or doing modulo of one integer by the integer or the float zero is hardware dependant and usually return the float +infinity for division and NaN for modulo. You can test it using the builtin <code>$isinfinite</code>, and there is also <code>$isnan</code> for testing NaN :
</p>

<pre>
	$print($isinfinite(1/0)); // prints true
	$print($isnan(0/0)); // prints true
</pre>

<p>
	Objects does also have theses operations overridable, see the Objects section.
</p>

<p>
	Please note also that overflow on integer operations does not convert them to floats and are not catchable errors. If you want to control overflow you can define your own functions for operations or use floats everywhere, or if you want exact arithmetic use an object with overridden operators.
</p>

<a name="bitwise"></a>
<h3>Bitwise operations</h3>

<p>
	The following operations are available for integers only, the perform on a bit basis. Please remember that for performances reasons, Neko integers are signed and 31 bits only, so there is only 30 bits of "unsigned" part :
</p>

<ul>
	<li><code>&lt;&lt;</code> left bit shift</li>
	<li><code>&gt;&gt;</code> right bit shift</li>
	<li><code>&gt;&gt;&gt;</code> right unsigned bit shift</li>
	<li><code>|</code> or bits</li>
	<li><code>&amp;</code> and bits</li>
	<li><code>^</code> xor bits</li>
</ul>

<p>
	Using the operations if one of the two operands is not an integer raise an exception.
</p>

<a name="boolops"></a>
<h3>Boolean operations</h3>

<p>
	To convert any value to a boolean, you can use the following builtin :
</p>

<p>
	<code>$istrue</code> :
</p>
<ul>
	<li>null : false</li>
	<li>int : false if 0, true either</li>
	<li>float : true</li>
	<li>string : true</li>
	<li>bool : itself</li>
	<li>object : true</li>
	<li>array : true</li>
	<li>function : true</li>
</ul>

<p>
	As you can see, only the values <code>null</code>, the boolean <code>false</code> and the integer <code>0</code> evaluates to false.
</p>


<p>
	<code>$not</code> :
</p>

<p>
	<code>$not</code> is the inverse of <code>$istrue</code>, it returns the other boolean returned by <code>$istrue</code>.
</p>

<p>
	Operations BooleanAnd ( &amp;&amp; ) and BooleanOr ( || ) :
</p>

<p>
	Boolean operations are short-circuited. That means that if the first operand of an <code>&amp;&amp;</code> is <code>false</code> or the first operand of an <code>||</code> is <code>true</code>, than the second operand is not evaluated and the first value is returned. Otherwise, the second value is returned.
</p>

<p>
	Please note that there is no automatic conversion to boolean done. <code>a && b</code> is equivalent to <code>if( a == false ) b else a</code> and <code>a || b</code> is equivalent to <code>if( a == true ) a else b</code> with <code>a</code> being evaluated only once. You might prefer to call <code>$istrue</code> on each argument before performing the operation.
</p>

<a name="compares"></a>
<h3>Equality &amp; Comparisons</h3>

<p>
	Comparison occurs when the following operations are performed : equality <code>==</code>, difference<code>!=</code>, greater <code>&gt;</code>, lower <code>&lt;</code>, greater or equal <code>&gt;=</code> or lower or equal <code>&lt;=</code>.
</p>

<p>
	Comparison method :
</p>


<table>
<tr>
	<th> $compare </th>
	<th>null</th>
	<th>int</th>
	<th>float</th>
	<th>string</th>
	<th>bool</th>
	<th>object</th>
	<th>array</th>
	<th>function</th>
</tr>
<tr>
	<th>null</th>
	<td>0</td>
	<td>-</td>
	<td>-</td>
	<td>-</td>
	<td>-</td>
	<td>-</td>
	<td>-</td>
	<td>-</td>
</tr>
<tr>
	<th>int</th>
	<td>-</td>
	<td>icmp</td>
	<td>fcmp</td>
	<td>strcmp</td>
	<td>-</td>
	<td>-</td>
	<td>-</td>
	<td>-</td>
</tr>
<tr>
	<th>float</th>
	<td>-</td>
	<td>fcmp</td>
	<td>fcmp</td>
	<td>strcmp</td>
	<td>-</td>
	<td>-</td>
	<td>-</td>
	<td>-</td>
</tr>
<tr>
	<th>string</th>
	<td>-</td>
	<td>strcmp</td>
	<td>strcmp</td>
	<td>strcmp</td>
	<td>strcmp</td>
	<td>-</td>
	<td>-</td>
	<td>-</td>
</tr>
<tr>
	<th>bool</th>
	<td>-</td>
	<td>-</td>
	<td>-</td>
	<td>strcmp</td>
	<td>bcmp</td>
	<td>-</td>
	<td>-</td>
	<td>-</td>
</tr>
<tr>
	<th>object</th>
	<td>-</td>
	<td>-</td>
	<td>-</td>
	<td>-</td>
	<td>-</td>
	<td>ocmp</td>
	<td>-</td>
	<td>-</td>
</tr>
<tr>
	<th>array</th>
	<td>-</td>
	<td>-</td>
	<td>-</td>
	<td>-</td>
	<td>-</td>
	<td>-</td>
	<td>acmp</td>
	<td>-</td>
</tr>
<tr>
	<th>function</th>
	<td>-</td>
	<td>-</td>
	<td>-</td>
	<td>-</td>
	<td>-</td>
	<td>-</td>
	<td>-</td>
	<td>acmp</td>
</tr>
</table>

<p>
	Here's the detail of each comparison function :
</p>

<ul>
	<li>icmp compare two integers a and b, returns 0 if they're equal, -1 if b &gt; a and 1 if a &gt; b.</li>
	<li>fcmp is the same as icmp but compares floats instead of integers.</li>
	<li>strcmp compares strings, it can be seen as a icmp applied to every byte of the two strings.</li>
	<li>acmp compares two addresses a and b,  returns 0 if they're the same, -1 if b&gt;a and 1 if a&gt;b</li>
	<li>bcmp returns 0 if a and b are both true or both false, 1 if a is true and b and false, -1 if a is false and b is true.</li>
	<li>ocmp does "object comparison". If the two objects addresses are same, then it returns 0, else it calls the method <code>__compare</code> on the first object, with the second object as argument. If the returned value is an integer, the integer is returned by $compare, else null is returned.</li>
	<li> - means that the comparison is invalid, the returned value is null when using $compare and false when using an operator.</li>
</ul>

<p>
	The following table show how each operation is performing depending on the result of <code>$compare</code> :
</p>

<table>
<tr>
	<th> op </th>
	<th>null</th>
	<th>-1</th>
	<th>0</th>
	<th>1</th>
</tr>
<tr>
	<th> == </th>
	<td>false</td>
	<td>false</td>
	<td>true</td>
	<td>false</td>
</tr>
<tr>
	<th> != </th>
	<td>true</td>
	<td>true</td>
	<td>false</td>
	<td>true</td>
</tr>
<tr>
	<th> &lt;= </th>
	<td>false</td>
	<td>true</td>
	<td>true</td>
	<td>false</td>
</tr>
<tr>
	<th> &lt; </th>
	<td>false</td>
	<td>true</td>
	<td>false</td>
	<td>false</td>
</tr>
<tr>
	<th> &gt;= </th>
	<td>false</td>
	<td>false</td>
	<td>true</td>
	<td>true</td>
</tr>
<tr>
	<th> &gt; </th>
	<td>false</td>
	<td>false</td>
	<td>true</td>
	<td>true</td>
</tr>
</table>

<p>
	Physical comparison :
</p>

<p>
	The builtin <code>$pcompare</code> will compare two values physicaly. It will be the same result as <code>$compare</code> for integers, and other values will be compared using their memory address. You can use <code>$pcompare</code> instead of <code>$compare</code> if you want to optimize your integer comparisons.
</p>

<a name="assigns"></a>
<h3>Assigns</h3>

<p>
	The following operations are also available in order to modify the value of a variable, object field, array content...
</p>

<p>
	The standard assign operation is <code>=</code>. There is also the following assigns that perform an operation at the same time. The return value is always the assigned value :
</p>

<pre>
	+= -= *= /= %= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;= |= &= ^=
</pre>

<p>
	There is two additional operations <code>++=</code> and <code>--=</code> that are doing the same as <code>+=</code> and <code>-=</code> except that the returned value is the value of the variable before it was modified :
</p>

<pre>
	a = 0;
	$print(a ++= 1); // 0
	$print(a ++= 1); // 1
	$print(a); // 2
</pre>

<a name="converts"></a>
<h3>Conversions</h3>

<p>
To convert any value to a Boolean, you can use the <code>$istrue</code> builtin, as specified in <a href="#boolops">Boolean operations</a>.
</p>

<pre>
	$istrue(null); // false
	$istrue(1); // true
</pre>

<p>
To convert a string or a float to an integer, you can use the <code>$int</code> builtin :
</p>

<pre>
	$int(45.67); // 45
	$int("67.87"); // 67
	$int($array(4)); // null
</pre>

<p>
To convert a string to a float you can use the <code>$float</code> builtin :
</p>

<pre>
	$float("1.345"); // 1.345
	$float(12345); // 12345.0000
	$float($array()); // null
</pre>

<p>
Any value can be converted to a string using <code>$string</code>, this operation is used in particular in the <code>$print</code> builtin :
</p>

<pre>
	$string(null); // "null"
	$string(123); // "123"
	$string($array(1,2,3)); // "[1,2,3]"
</pre>

<p>
	On objects, <code>$string</code> calls the <code>__string</code> method on the object if it exists. If the returned value is a string, this string is returned, else the string <code>#object</code> is returned.
</p>

<p>
	On functions, <code>#function:n</code> is returned where <code>n</code> is the number of arguments of the function (or -1 if multiple arguments).
</p>

<a name="optim"></a>
<h3>Optimized Operations</h3>

<p>
There is several optimized operations on integers : <code>$iadd, $isub, $imult, $idiv</code>. They are all skipping some typechecks so are more fast. Their results will always be a valid integer, but its value is unspecified when one of the two values is not an integer. <code>$idiv</code> raise an exception when division by 0 occurs :
</p>

<pre>
	$print( $iadd(1,3) ); // 4
	$print( $idiv(5,3) ); // 2
	$print( $idiv(1,0) ); // exception
</pre>

<!-- ****************************************************************************** -->

<a name="rtti"></a>
<h2>Runtime Type Information (RTTI)</h2>

<p>
	Whatever if your language is staticly or dynamicly typed, you can always access RTTI in Neko. RTTI is powerful because you can at runtime decide which behavior to adopt depending of some value. The most common application is to print some debug informations, another one is introspection : the ability to look inside an object, read its fields and call its methods.
</p>

<p>
The builtin <code>$typeof</code> returns an integer specifying the type of a value according to the following table :
</p>

<table>
<tr>
	<th>Type</th>
	<th>Constant</th>
	<th>Value</th>
</tr>
<tr>
	<td>null</td>
	<td><code>$tnull</code></td>
	<td>0</td>
</tr>
<tr>
	<td>int</td>
	<td><code>$tint</code></td>
	<td>1</td>
</tr>
<tr>
	<td>float</td>
	<td><code>$tfloat</code></td>
	<td>2</td>
</tr>
<tr>
	<td>bool</td>
	<td><code>$tbool</code></td>
	<td>3</td>
</tr>
<tr>
	<td>string</td>
	<td><code>$tstring</code></td>
	<td>4</td>
</tr>
<tr>
	<td>object</td>
	<td><code>$tobject</code></td>
	<td>5</td>
</tr>
<tr>
	<td>array</td>
	<td><code>$tarray</code></td>
	<td>6</td>
</tr>
<tr>
	<td>function</td>
	<td><code>$tfunction</code></td>
	<td>7</td>
</tr>
<tr>
	<td>abstract</td>
	<td><code>$tabstract</code></td>
	<td>8</td>
</tr>
</table>

<p>
	Example :
</p>

<pre>
	$typeof(3); // 1
	$typeof($array(1,2)); // 6
	$typeof(null) == $tnull; // true
</pre>

<p>
	You can use the builtins for <a href="#objects">Objects</a>, <a href="#strings">Strings</a>, <a href="#functions">Functions</a> and <a href="#arrays">Arrays</a> to manipulate them at runtime.
</p>

<!-- ****************************************************************************** -->

<a name="functions"></a>
<h2>Function &amp; Function Calls</h2>

<p>
Defining new functions is easy, since functions are values, you can simply assign them to a local or a global variable :
</p>

<pre>
	var foo = function() {
		return 0;
	}
</pre>

<p>
	Functions are called by-value, that means that <code>foo(1)</code> calls the function which is the value of the variable foo. Calling a value that is not a function or that does not accept this number of arguments will raise an exception.
</p>

<p>
	You can know the number of arguments needed by a function by using the builtin <code>$nargs</code>. A function that accepts a variable number of arguments returns -1 when used with <code>$nargs</code>. Please note also that builtins can be used as values :
</p>

<pre>
	$print($nargs(function(a,b) { return a + b; }); // prints 2
	$print($nargs($print)); // prints -1
	$print($nargs(0)); // exception
</pre>

<p>
	There is one other way of calling a function : builtin <code>$call</code> takes an array of arguments and a object context (see Objects section) as parameters. This builtin can be useful for introspection :
</p>

<pre>
	// call the foo function with null context
	// and two parameters 3 and 4
	$call(foo,null,$array(3,4));
</pre>

<p>
	Functional languages require partial application (aka currying) : the ability to creates closures by setting a fixed number of arguments of a function, leaving the rest for later call. The builtin <code>$closure</code> enable to create a closure :
</p>

<pre>
	var add = function(x,y) { return x + y };
	var plus5 = $closure(add,null,5); // null context and 5 as first argument
	$print( plus5(2) ); // 7
</pre>

<p>
	The builtin <code>$closure</code> can also be used to fix the <code>this</code> context of a function :
</p>

<pre>
	var f = function() { $print(this) };
	f = $closure(f,55);
	f(); // prints 55
</pre>

<p>
	Some languages might want more security about the types of the arguments that are passed to a function, or selecting at runtime different implementations of a function depending on the type of the arguments. There are many ways of doing that in Neko. For example, you might want to add arguments checks at the beginning of the function body using runtime types informations (RTTI) builtins.
</p>

<p>
	Another useful builtin is <code>$apply</code> which is identical to a direct function call except that if the function require extra arguments then its call is delayed until further arguments are used :
</p>

<pre>
	var f = function(x,y) { return x + y };
	f(1,2);
	$apply(f,1)(2); // equivalent
	$apply(f,1,2); // equivalent
</pre>

<!-- ****************************************************************************** -->

<a name="objects"></a>
<h2>Objects</h2>

<p>
	Objects are some kind of optimized hashtables. All fields names are hashed into an integer value that is used as the key into a lookup table. Insertion of a new field is <code>O(n)</code>, access to a field is <code>O(log n)</code>. If you're generating from a staticly typed programming language, you might prefer arrays for storing fields, since they provide <code>O(1)</code> access.
</p>

<p>
	To create an object, you can use the builtin <code>$new</code>, that can either returns a copy of an object or a new object :
</p>

<pre>
	o = $new(null); // new empty object
	o2 = $new(o); // makes a copy of o
	o2 = $new(33); // if parameter is not an object, throw an exception
</pre>

<p>
	You can set fields of an object using dot access or using the builtin <code>$objset</code> :
</p>

<pre>
	o.field = value;
	$objset(o,$hash("field"),value);
</pre>

<p>
	Accessing object fields for reading use either dot access or builtin <code>$objget</code> :
</p>

<pre>
	o.field; // returns "field" value of object o
	$objget(o,$hash("field")); // returns "field" value of object o
</pre>

<p>
	Please note that <code>$objset</code> and <code>$objget</code> second parameter is hashed at runtime so it's a bit less efficient operation than dot access but enables introspection.
</p>

<p>
	If a field is not defined when accessed for reading, the <code>null</code> value is returned. If a field does not exists when a field is accessed for writing, the field is added.
</p>

<p>
	To check for a field existance, you can use the <code>$objfield</code> builtin that checks if an object o have a given field, even if that field is set to the <code>null</code> value :
</p>

<pre>
	$objfield(o,$hash("field")); // true if o have "field"
	$objfield(null,33); // false
</pre>

<p>
	You can remove an object field with the <code>$objremove</code> builtin :
</p>

<pre>
	$objremove(o,$hash("field")); // remove "field" from o
</pre>

<p>
	One other way to declare objects is to use the following notation, which is more efficient when you want initialize several fields at the same time :
</p>

<pre>
	var o = {
		x => 0,
		y => -1,
		msg => "hello"
	}
</pre>

<h3>Methods</h3>

<p>
	When a function is called using the dot access or the builtin <code>$objcall</code>, the function can access a special variable named <code>this</code> which is the "object context" (the object with which the function was called) :
</p>

<pre>
	o = $new(null);
	o.x = 1;
	o.add = function(y) { return this.x + y; }
	$print(o.add(2)); // prints 3
	$print( $objcall(o,$hash("add"),$array(2)) ); // prints 3
</pre>

<p>
	The context value <code>this</code>, like true or false, cannot be modified directly. The context is set when a object function is called and can be accessed from any sub function :
</p>

<pre>
	foo = function() {
		$print(this.x);
	}
	o = $new(null);
	o.x = 3;
	o.bar = function() { foo(); };
	o.bar(); // prints 3
</pre>

<p>
	You can modify the value of <code>this</code> at runtime by simply assigning it to another value. It can be set to any value, not only objects. When returning from an object call, the context is restored, so any modifications are lost :
</p>

<pre>
	this = 1;
	o.foo = function() {
		// here , we have this = o;
		this = 2; // modify
	};
	o.foo();
	$print(this); // 1
</pre>

<h3>Fields lists</h3>

<p>
	As explained before, fields names are first hashed into integer values for faster access. In order to avoid collisions in the hashing functions, they are then stored into a global table than will check that hash(x) = hash(y) implies that x = y. The other utility of this library is to be able to reverse the hashing function at runtime, that can be useful to print the field names of an object, for debugging purpose for example.
</p>

<p>
	You can use the following builtins : <code>$hash</code> returns the integer hashing value of a string, or raise an exception in case of collision. <code>$field</code> transforms an integer into a previously hashed string or returns <code>null</code>.
</p>

<p>
	The builtin <code>$objfields</code> returns an array containing all fields identifiers for the given object :
</p>

<pre>
	var a = $objfields(o);
	var i = 0;
	while( i < $asize(a) ) {
		var fname = $field(a[i]);
		var fval = $objget(o,a[i]);
		$print( fname + " = " + fval + "\n" );
		i = i + 1;
	}
</pre>

<h3>Operators Overloading</h3>

<p>
	Several operators can be overloaded so when they're applied to objects they are actually calling methods. Here's a list of operators overloadable and corresponding methods names :
</p>

<ul>
	<li><b>string conversion</b> : call the <code>__string</code> method on the object with no arguments. A string should be returned.</li>
	<li><b>object comparison</b> : for any comparison between two different objects, the <code>__compare</code> method is called on the first object with the second object as parameter.</li>
	<li><b>addition</b> : in the case of <code>a + b</code>, if <code>a</code> is an object, <code>a.__add(b)</code> is called else if <code>b</code> is an object, <code>b.__radd(a)</code> is called.
	<li><b>subtraction</b> : same as addition but with <code>__sub</code> and <code>__rsub</code>.</li>
	<li><b>multiplication</b> : same as addition but with <code>__mult</code> and <code>__rmult</code>.</li>
	<li><b>division</b> : smae a addition but with <code>__div</code> and <code>__rdiv</code>.</li>
	<li><b>modulo</b> : same as addition but with <code>__mod</code> and <code>__rmod</code>.</li>
	<li><b>array reading</b> : when an object is accessed as an array for reading, using <code>a[i]</code> actually calls <code>a.__get(i)</code>.</li>
	<li><b>array writing</b> : when an object is accessed as an array for writing, using <code>a[i] = v</code> actually calls <code>a.__set(i,v)</code>.</li>
</ul>

<p>
	If the overloaded field is not defined when an operation occured, an exception is raised.
</p>

<h3>Prototypes</h3>

<p>
	Each object can have a <i>prototype</i> which is also an object. When a field is accessed for reading and is not found in an object, it is searched in its prototype, and like this recursively.
</p>

<p>
	Prototypes can be accessed using <code>$objgetproto</code> and <code>$objsetproto</code> :
</p>

<pre>
	var proto = $new(null);
	proto.foo = function() { $print(this.msg) }

	var o = $new(null);
	o.msg = "hello";
	$objsetproto(o,proto);
	o.foo(); // print "hello"

	$objsetproto(o,null); // remove proto
	o.foo(); // exception
</pre>

<!-- ****************************************************************************** -->

<a name="arrays"></a>
<h2>Arrays</h2>

<p>
	Array is a type. That means that Neko arrays (and Neko strings and booleans as well) are not objects. If in your language arrays are objects, then you can write an object wrapper using an array value to store the data, and matching the API of your language.
</p>

<p>
	Creating an array can be done using the <code>$array</code> builtin, and accessing an array can be done using the brackets syntax. You can also create an array with a specific size using the <code>$amake</code> builtin :
</p>

<pre>
	var a = $amake(0); // empty array
	a = $array(1,3,"test"); // array with three values

	$print(a[0]); // 1
	$print(a[2]); // "test"
	$print(a[3]); // null
	$print(a["2"]); // null
</pre>

<p>
	Arrays are accessed with integer key values, every other key value type will raise an exception. If the integer is in the range of the array bounds (between 0 and <code>$asize(a) - 1</code>), then the value returned is the one stored at this index, else it's <code>null</code>. For writing, if a value is written outside the bounds of the array then the array is not modified. You can get the size of an array using the <code>$asize</code> builtin. Arrays are not resizable :
</p>

<pre>
	a = $array(1,2,3);
	$print($asize(a)); // prints 3
</pre>

<p>
	If you want to make a copy of an array or only of a part of an array, there is the <code>$acopy</code> and the <code>$asub</code> builtins. Please note that <code>$asub</code> can't access outside the bounds of the array :
</p>

<pre>
	a = $array(1,2,3,4);
	$print( $acopy(a) ); // [1,2,3,4] , a copy can be modified separatly
	$print( $asub(a,1,2) ); // [2,3]
	$print( $asub(a,3,3) ); // null
	$print( $asub(a,-2,3) ); // null
</pre>

<p>
	There is also a <code>$ablit</code> function to copy elements from one array to another :
</p>

<pre>
	a = $array(1,2,3,4);
	b = $array(6,7,8);
	$ablit(a,1,b,0,2); // copy 2 elements from b+0 to a+1
	$print(a); // [1,6,7,4]
</pre>

<p>
	Arrays can contain a maximum of 2^39 - 1 éléments, or <code>$amake</code> and <code>$array</code> will raise an exception.
</p>

<!-- ****************************************************************************** -->

<a name="strings"></a>
<h2>Strings</h2>

<p>
	Like arrays, strings are a type and not objects. They are arrays of bytes, so can be convenient for storing large quantity of small numbers or binary data, that might not be scanned by the Garbage Colllector. Please note that unlike C language, the size of the string is stored so you can easily put binary data into it without caring about ending \000 character.
</p>

<p>
	Constant strings can contain any character, including newlines and binary data. However doublequotes and backslashs need to be escaped. A backslash is used for escaping some special characters, here's a list of recognized escape sequences :
</p>

<ul>
	<li><code>\"</code> : doublequote</li>
	<li><code>\\</code> : backslash</li>
	<li><code>\n</code> : newline</li>
	<li><code>\r</code> : carriage return</li>
	<li><code>\t</code> : tab</li>
	<li><code>\xxx</code> : xxx are three digits that represent a decimal binary code between 000 and 255</li>
</ul>

<p>
	Strings can be created using the <code>$smake</code> builtin with a given size. Once allocated, a string can't be resized. The size of a string can be retrieved using the <code>$ssize</code> builtin :
</p>

<pre>
	s = $smake(16);
	s = "hello";
	$print( $ssize(s) ); // 5
</pre>

<p>
	Please note that assigning a constant string does not makes a copy of it, so the constant content can be modified. Also, several same constant strings can be merged into the same string, so you might be careful about unexpected side effects when modifying a constant string. You might want to use a <code>$scopy</code> or the <code>$ssub</code> builtins (similar to array ones) :
</p>

<pre>
	s = $scopy("hello");
	$print( $ssub(s,1,3) ); // "ell"
</pre>

<p>
	Access to strings bytes can be done using the <code>$sget</code> and <code>$sset</code> builtins. <code>$sget</code> returns a integer between 0 and 255 or <code>null</code> if outside the string bounds. <code>$sset</code> write the given integer value converted to an unsigned integer and modulo 256 :
</p>

<pre>
	$s = $smake(1);
	$sset(s,0,3684); // set byte 0 to 3624 mod 256
	$print( $sget(s,0) ); // prints 40
</pre>

<p>
	You can copy big chunks of bytes from one string to another using the <code>$sblit</code> builtin. It returns the number of bytes copied or <code>null</code> if the copy failed  :
</p>

<pre>
	s = "some string to blit from";
	s2 = $smake(14);
	$sblit(s2,0,s,5,14);
	$print(s2); // "string to blit"
</pre>

<p>
	To find a substring in a string, you can use the <code>$sfind</code> builtin :
</p>

<pre>
	s = "some string to search";
	$print($sfind(s,0,"to")); // 12
	$print($sfind(s,20,"to")); // starting a byte 20 : null
</pre>

<p>
	Strings can contain a maximum of 2 ^ 29 - 1 characters, or <code>$smake</code> will raise an exception.
</p>

<!-- ****************************************************************************** -->

<a name="exceptions"></a>
<h2>Exceptions</h2>

<p>
Exceptions are often referred as "non local jumps". It's a very good way for handling errors than can happen at several calls between the function that yields an error and the handler that will take care of it. Raising an exception is done using the <code>$throw</code> builtin, and catching it is done using the <code>try...catch</code> syntax. Please note that any value can be an exception, it's up to you to decide which structure you want to use :
</p>

<pre>
	var foo = function() {
		$throw("failure");
	}
	try
		foo()
	catch e {
		$print(e); // prints "failure"
	}
</pre>

<p>
	Every time an exception is catched, the <i>exception stack</i> is stored and can be retrieved using the builtin <code>$excstack()</code>. It contains the filenames and positions of the different calls between the <code>try</code> and the place the exception was raised.
</p>

<pre>
	try
		foo()
	catch e {
		$print(e," raised from : ",$excstack());
	}
</pre>

<p>
	In some cases, you want to filter exceptions and catch only some of theses. You need then to catch all the exceptions, check if the exception is filtered, and raise it again if not. However, in order to loose the exception stack by throwing a new exception, you can use the <code>$rethrow</code> builtin that will add the two stacks together (the current one and the one to the next <code>catch</code>).
</p>

<pre>
	try
		foo()
	catch e {
		if( $typeof(e) == $tint )
			$print("catched !")
		else
			$rethrow(e);
	}
</pre>

<p>
	Please note that you can <code>rethrow</code> another exception, so it's more easy to rewrap some Neko libraries exceptions with your own format.
</p>

<p>
	It is also possible to get the current call stack at any point of a Neko program using the <code>$callstack()</code> builtin.
</p>

<!-- ****************************************************************************** -->

<a name="hash"></a>
<h2>Hashtables</h2>

<p>
	There is a set of builtins that are useful for using Hashtables. An hashtable is not a basic type but an <i>abtract</i> type. It can then only be manipulated using the following builtins :
</p>

<ul>
	<li><code>$hnew(size)</code> : create a new hashtable having initialy <code>size</code> slots.</li>
	<li><code>$hadd(h,k,v)</code> : add the value <code>v</code> with key <code>k</code> to the hashtable. Please note that <code>k</code> can be any Neko value, even recursive.</li>
	<li><code>$hset(h,k,v,cmp)</code> : set the value of the key <code>k</code> to <code>v</code>. The previous binding is replaced if the <code>cmp</code> function between keys returns 0. If <code>cmp</code> is <code>null</code>, the default comparison function is used.</li>
	<li><code>$hmem(h,k,cmp)</code> : returns true if a value exists for key <code>k</code> in the Hashtable.</li>
	<li><code>$hget(h,k,cmp)</code> : returns the first value bound to key <code>k</code> or <code>null</code> if not found.</li>
	<li><code>$hremove(h,k,cmp)</code> : removes the first binding of <code>k</code>. returns a boolean indicating the success.</li>
	<li><code>$hresize(h,size)</code> : resize the hashtable. Please note that the size is usually automaticaly handled.</li>
	<li><code>$hsize(h)</code> : returns the size of the hashtable.</li>
	<li><code>$hcount(h)</code> : returns the number of bindings in the hashtable.</li>
	<li><code>$hiter(h,f)</code> : calls <code>f(k,v)</code> for each binding found in the hashtable.</li>
</ul>

<p>
	The hashtable stores the (key,values) couples in one chained list per slot. Adding a new binding with the same key will mask the previous one. The hash function used internaly is <code>$hkey(k)</code> which will return a positive Neko integer for any Neko value. The hash function cannot be overriden but the comparison function between keys can be where it is used.
</p>

<p>
	You can of course write your own hashtable implementation using Neko data structures, but using the standard builtin hashtable is better for languages interoperability.
</p>

<!-- ****************************************************************************** -->

<a name="labels"></a>
<h2>Labels and Gotos</h2>

<p>
	It is sometimes useful to be able to jump directly at some code location. Labels are providing a way to <em>mark</em> a location in the code and the builtin <code>$goto</code> can jump to a label :
</p>

<pre>
    $print("enter");
    $goto(next);
    $print("skipping");
    next:
    $print("done");
</pre>

<p>
	Please note that labels identifiers are globals to the file, but cannot be defined in all expressions. The reason is to simplify the compiler since labels normaly require multiple passes for stack preservation (see below). In the case a label cannot be declared an error is printed at compilation-time. The builtin <code>$goto</code> can only be used with a valid label identifier, in that case only, the identifier is treated as a label and not as a variable.
</p>

<h3>Gotos and Stack Preservation</h3>

<p>
	In all cases, gotos to labels are preserving the stack. For example in the following case, the variable "x" is popped out of the stack when the goto occurs :
</p>

<pre>
    {
        var x = 0;
        $goto(next);
    }
    next:
</pre>

<p>
	If the goto is done <em>inside</em> a block having defined local variables, theses variables are also accessible but their values are unspecified :
</p>

<pre>
    $goto(next);
    {
        var x = 0;
        next:
        $print(x);
    }
</pre>


<h3>Gotos and Exceptions</h3>

<p>
	In the same way gotos are preserving the stack size, they are also preserving the exception handlers, such as the following program is correctly compiled :
</p>

<pre>
    try {
        $goto(next);
    } catch e {
        ...
    }
    next:
</pre>

<p>
	In the case a goto is done inside a <code>try...catch</code> block, a temporary exception handler will be set that will only reraise the exception. The exception is not handled by the <code>catch</code> block since the <code>try</code> setup have been skipped :
</p>

<pre>
    $goto(next);
    try {
        next:
        $throw("error");
    } catch e {
        ...
    }
</pre>


<!-- ****************************************************************************** -->

<h1>End</h1>

<p>
	Hope you didn't fell asleep while reading this long document. <em>Questions ?</em> Use the <a href="/?doc=doc">Mailing List</a>.
</p>
