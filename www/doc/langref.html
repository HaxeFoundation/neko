<html>

<head>
<title>Neko Language Specification</title>
</head>
<body bgcolor="white">

<h1>Neko Language Specification</h1>

<h2>Introduction</h2>

<p>
Neko is an <i>intermediate</i> programming language designed to provide a common runtime for various imperative or functionnal, staticly or dynamicly typed high-level programming languages.
</p>

<p>
Every new programming language has now to deal with an huge amount of stuff in order to be taken seriously and labelled "usable". This can be some general properties such as an OO layer, decent runtime speed, dynamic loading  and reflection, but most of the work have to be put into librairies : Network, Xml, Internet protocols, Graphical User Interface, and so on... Such an amount of work makes new language long time to take off and the language designer can't focus anymore on features and design. This state has bring us to an era where outdated poor and uncool programming languages such as Java are ruling the business world, not because of its qualities and features but because of the ability of the industry to leverage it and reuse large librairies of code.
</p>

<p>
On the other side, Microsoft have an interesting approach with its DotNet platform : Free the language designer from a lot of work by providing a common framework being able to run a wide variety of languages. Looks very nice and promising on the paper, but there are several problems with it :
</p>

<ul>
<li>DotNet runs only on Windows (even if Mono is trying to keep up with it).</li>
<li>DotNet performs poorly with functional languages (until maybe <a href="http://research.microsoft.com/projects/ilx/ilx.aspx">ILX</a> is incorporated into it).</li>
<li>DotNet have been designed to run mainly OO staticly typed language (such as C#).</li>
<li>DotNet is heavyweighted for small applications.</li>
<li>DotNet is not Open Source.</li>
<li>DotNet bytecode have a high learning curve and it is not easy to generate to it.</li>
</ul>

<p>
Some other alternatives are available, but they're either too much low-level (<a href="http://llvm.cs.uiuc.edu">LLVM</a>) or dedicated to dynamicly typed languages  (<a href="http://www.parrotcode.org">Parrot</a>). As a <a href="http://ncannasse.free.fr/index.php?p=19">language designer</a> and <a href="http://www.mtasc.org">compiler writer</a>, I have my own way of thinking about multilanguage framework with code reusability, so I decided to give it a try.
</p>


<h2>Syntax</h2>

<p>
Neko language syntax have been created with "easy to parse" and "easy to generate" in mind. It is not especially designed to be written by a programmer but more to be generated from a higher level language. For example one could write easily a PHP-to-Neko or a Java-to-Neko that would generate equivalent code but using Neko syntax and semantics instead of PHP or Java ones.
</p>

<p>
In particular, there are not multiple levels of expression, as in C. Every statement is also an expression, and thus enable some constructs that are not possible in other languages (for example : <code>return if(x) { ... } else { ... }</code>). This make the generation to Neko from functional languages more easy.
</p>

<p>
The syntax is parsed using a left-to-right LL(1) parser. That means that after reading a token we have enough information to know which expresion it will produce. This enable very lightweight parser which is easy to improve without creating ambiguities. Here's an Abstract Syntax Tree description of the language syntax, with the additionnal constraint that a program must be terminated by EOF :
</p>

<pre>
	    <i>program</i> :=
		| <i>expr</i> <i>program</i>
		| <b>SEMICOLON</b> <i>program</i>
		| &epsilon;

	    <i>ident</i> :=
		| [a-zA-Z_@] [a-zA-Z0-9_@:]*

	    <i>binop</i> :=
		| [!=*/&lt;&gt;&|^%+:-]+

	    <i>value</i> :=
		| [0-9]+
		| 0x[0-9A-Fa-f]+
		| [0-9]+ <b>DOT</b> [0-9]*
		| <b>DOT</b> [0-9]+
		| <b>DOUBLEQUOTE</b> <i>characters</i> <b>DOUBLEQUOTE</b>
		| <b>DOLLAR</b> <i>ident</i>
		| <b>SHARP</b> <i>ident</i>
		| <b>QUOTE</b> <i>ident</i>
		| <b>true</b>
		| <b>false</b>
		| <b>null</b>
		| <b>this</b>
		| <i>ident</i>

	    <i>expr</i> :=
		| <i>value</i>
		| <b>{</b> <i>program</i> <b>}</b>
		| <i>expr</i> <b>DOT</b> <i>ident</i>
		| <i>expr</i> <b>(</b> <i>parameters</i> <b>)</b>
		| <i>expr</i> <b>[</b> <i>expr</i> <b>]</b>
		| <i>expr</i> <i>binop</i> <i>expr</i>
		| <b>(</b> <i>expr</i> <b>)</b>
		| <b>var</b> <i>variables</i>
		| <b>for (</b> <i>expr</i> <i>expr</i> <i>expr</i> <b>)</b> <i>expr</i>
		| <b>while</b> <i>expr</i> <i>expr</i>
		| <b>do</b> <i>expr</i> <b>while</b> <i>expr</i>
		| <b>if</b> <i>expr</i> <i>expr</i> [<b>else</b> <i>expr</i>]
		| <b>try</b> <i>expr</i> <b>catch</b> <i>ident</i> <i>expr</i>
		| <b>function (</b> <i>parameters-names</i> <b>)</b> <i>expr</i>
		| <b>return</b> [<i>expr</i> | <b>SEMICOLON</b>]
		| <b>break</b> [<i>expr</i> | <b>SEMICOLON</b>]
		| <b>continue</b>

	    <i>variables</i> :=
		| <i>ident</i> [<b>=</b> <i>expr</i>] <i>variables</i>
		| <b>COMMA</b> <i>variables</i>
		| &epsilon;

	    <i>parameters</i> :=
		| <i>expr</i> <i>parameters</i>
		| <b>COMMA</b> <i>parameters</i>
		| &epsilon;

	    <i>parameters-names</i> :=
		| <i>ident</i> <i>parameters-names</i>
		| <b>COMMA</b> <i>parameters-names</i>
		| &epsilon;

	    <i>cases</i> :=
		| <i>expr</i> <b>=></b> <i>expr</i> <i>cases</i>
		| <b>default</b> <b>=></b> <i>expr</i> <i>cases</i>
		| &epsilon;

</pre>

<p>
	<i>Random notes : </i>
</p>

<ul>
<li><code>continue</code> behavior in a <code>for</code> increments part (third expression) is undefined.</li>
<li><code>continue</code> and <code>break</code> outside a loop are not specified.</li>
<li><code>return</code> in the toplevel (outside a function) is an accepted way of interupting module execution without error.</li>
<li>There are some few ambiguous cases when two expressions follows each others (in for, while and if). If the second expression is inside parenthesis, it will be parsed as a call of first expression, while such a representation e1 (e2) exists in the AST (the semicolons are optional).</li>
</ul>

<h2>Values</h2>

<p>
A value in Neko can be one of the following :
</p>

<ul>
<li><b>Integer :</b> integers can be represented in either decimal form (such as <code>12345</code> or <code>-12</code>) or hexadecimal (<code>0x1A2B3C4D</code>).</li>
<li><b>Floating point :</b> floating point values are represented using a dot (such as <code>12.345</code> or <code>-0.123</code>)</li>
<li><b>String :</b> strings are double quoted (such as <code>"foo"</code>, or <code>"hello,\nworld !"</code>, or <code>"My name is \"Bond\\James Bond\"."</code>). Neko strings are immutable, that means that you cannot modify them.</li>
<li><b>Boolean :</b> the two booleans are available as specific lowercased identifiers : <code>true</code> and <code>false</code>.</li>
<li><b>Null :</b> the special value <code>null</code> is used for uninitialized variables as well as programmer/langage specific coding techniques.</li>
<li><b>Object :</b> an object is an association table, which bind an ident or a string to a value, see how you can create and manage objects later.</li>
<li><b>Array :</b> arrays are indexed table of values, starting at index 0, they provide fast random access.</li>
<li><b>Function :</b> a function is also a value in Neko, and can then be stored into any variable.</li>
</ul>

<p>
Some precisions :
</p>

<ul>
<li>integers are 31 bits for virtual machine performances reasons, an access to full 32 bits integers will be made possible soon.</li>
<li>floating points are 64 bits double precision floating points values.</li>
<li>strings are 8-bit binary values. A string can contain \0 characters, the string length is determined by the amount of data available and not by the number of characters before the first \0. Maximum string size might depend of virtual machine specification, but should be at least 65535 bytes.</i>
</ul>

<h2>Execution Flow</h2>

<p>
Here's some explanation on how each expression is evaluated :
</p>

<h3>
Values :
</h3>

<ul>
<li><code>[0-9]+ | 0x[0-9A-Fa-f]+</code> : evaluate to the corresponding integer value</li>
<li><code>[0-9]+ <b>DOT</b> [0-9]* | <b>DOT</b> [0-9]+</code> : evaluate to the corresponding floating point value</code></li>
<li><code><b>DOUBLEQUOTE</b> <i>characters</i> <b>DOUBLEQUOTE</b></code> : evaluate to the corresponding string. Escaped characters are simular to the C language.</li>
<li><code><b>DOLLAR</b> <i>ident</i></code> : identifiers prefixed with a dollar are primitives. They enable you to call some compiler constructors or optimized calls (see Primitives).</li>
<li><code><b>SHARP</b> <i>ident</i></code> : identifiers prefixed with a sharp are modules. See later for explanations of module loading and linking (see Modules).</li>
<li><code><b>QUOTE</b> <i>ident</i></code> : execute a macro at parsing-time (see Macros)</li>
<li><code><b>true</b> | <b>false</b></code> : evaluate to the corresponding boolean.</li>
<li><code><b>null</b></code> : evaluate to the null value.</li>
<li><code><b>this</b></code> : evaluate to the local object value (see later for objects).</li>
<li><code><i>ident</i></code> : evaluate to the value currently bound to this variable name.</li>
</ul>

<h3>Expressions</h3>
<p>
Before evaluating any expression, all sub-expressions are evaluated in an unspecified order. the "v" here are showing the values returned by evaluation of sub-expressions.
</p>

<ul>
<li><code><b>{</b> <i>v1, v2, .... vk</i> <b>}</b></code> : the evaluation order is specified here, it follows the expressions declarations. The last value <code>vk</code> is returned, or <code>null</code> if <code>program</code> does not contain any expression.</li>
<li><code><i>v</i> <b>DOT</b> <i>ident</i></code> : <code>v</code> is accessed as an object using <code>ident</code> as key (see Objects).</li>
<li><code><i>v</i> <b>(</b> <i>v1, v2, ... vk</i> <b>)</b></code> : the function <code>v</code> is called with the parameters <code>v1, v2... vk</code> (see Function Calls)</li>
<li><code><i>v1</i> <b>[</b> <i>v2</i> <b>]</b></code> : <code>v1</code> is accessed as an array using <code>v2</code> as key (see Arrays)</li>
<li><code><i>v1</i> <i>binop</i> <i>v2</i></code> : calculate v1 op v2 (see Operations).</li>
<li><code><i>expr</i> <i>assign-binop</i> <i>v</i></code> : this is a special case, when operation is an assignation (see Operations).</li>
<li><code><b>(</b> <i>v</i> <b>)</b></code> : evaluate to <code>v</code>.</li>
<li><code><b>var</b> <i>i1 = v1, i2 = v2, .... ik = vk</i></code> : each variable <code>i</code> is set to the corresponding value <code>v</code> or to <code>null</code> if no initialization expression is provided.</li>
<li><code><b>for</b>...</code> : classic for-loop, the value returned is either the value returned by a <code>break</code> inside the for or unspecified.</li>
<li><code><b>while</b> ....  | <b>do</b> ... <b>while</b> ...</code> : classic while-loop, same as for.</li>
<li><code><b>if</b> <i>v1</i> <i>e1</i></code> : if v1 is the boolean <code>true</code>, then <code>e1</code> is evaluated and its value returned, else the evaluated value is unspecified.</li>
<li><code><b>if</b> <i>v1</i> <i>e1</i> <b>else</b> <i>e2</i></code> : if v1 is the boolean <code>true</code>, then <code>e1</code> is evaluated and its value returned else <code>e2</code> is evaluated and its value returned.</li>
<li><code><b>try</b> <i>e1</i> <b>catch</b> <i>i</i> <i>e2</i></code> : evaluate <code>e1</code> and returns the evaluated value. If an exception is raised, then evaluate <code>e2</code> and returns evaluated value with local <code>i</code> variable being set to the raised exception value (see Exceptions).</li>
<li><code><b>function (</b> <i>parameters-names</i> <b>)</b> <i>expr</i></code> : evaluate to the corresponding function.</li>
<li><code><b>return</b>;</code> : exit current function with unspecified return value.</li>
<li><code><b>return</b> v</code> : exit current function and return value <code>v</code>.</li>
<li><code><b>break</b>;</code> : exit current for or while loop with unspecified return value.</li>
<li><code><b>break</b> v</code> : exit current for or while loop and return value <code>v</code>.</li>
<li><code><b>continue</b></code> : continue execution to next while/for loop step.</li>
</ul>

<p>
	Please note that <code>if</code>, <code>for</code> and <code>while</code> conditions only sucess for the boolean <code>true</code> and for no other value. You might need to add a <code>$isTrue</code> code before each expression in order to convert the expression result into a boolean.
</p>

<h2>Variables</h2>

<p>
When an identifier is found, it must be resolved to a given context holding the variable value. The first context searched for is the local context.
</p>

<h3>Local Context</h3>

<p>
The local context contains all variable defined with the "var" keyword in previous syntaxical blocks. In the following sample, <code>x</code> resolve to the value 3 :
</p>

<pre>
	var x = 3;
	$print(x);
</pre>

<p>
A "var" declaration is only local to the curly-braced block it has been declared in. For example :
</p>

<pre>
	var x = 3;
	// x defined
	if( ... ) {
		// x defined
		var y;
		// x and y defined;
	}
	// x defined
</pre>

<p>
Same variable name can be reused in same block or in another block. It will hide or erase previous value :
</p>

<pre>
	var x = 1;
	$print(x); // print 1
	var x = 3;
	$print(x); // print 3
	if( ... ) {
		var x = "neko";
		$print(x); // print "neko"
	}
	$print(x); // print 3
</pre>

<p>
Function parameters are also local variables, they are defined into the whole function :
</p>

<pre>
	var x = 3;
	f = function(x) {
		$print(x);
	}
	f("neko"); // print "neko"
</pre>

<p>
Since contexts are resolved at purely syntactic level, local variables does not depends on current call-stack, and you cannot access variables defined outside current local context.
</p>

<pre>
	f = function() {
		$print(x);
	}
	...
	var x = 3;
	f(); // null or error !
</pre>

<h3>Function Environment</h3>

<p>
Local variables can be used inside functions if they're accessible at the time the function is declared. In this case, the value of the variable is a copy of the value it had at the time the function was defined :
</p>

<pre>
	var x = 3;
	f = function() {
		$print(x);
	}
	x = 4;
	f(); // print 3
</pre>

<p>
Such variables are called environment variables because they're no longer part of the local context but of the function "environment" context. A function can still modify an environment variable but this will not modify the original variable reference :
</p>

<pre>
	var x = 3;
	f = function() {
		$print(x);
		x += 1;
	}
	x = 50;
	f(); // print 3
	f(); // print 4
	$print(x); // print 50
</pre>

<p>
Please note also that each function instance have its own environment :
</p>

<pre>
	gen = function() {
		var i = 0;
		return function() { $print(i); i += 1; };
	}
	f1 = gen();
	f2 = gen();
	f1(); // print 0
	f1(); // print 1
	f2(); // print 0
	f1(); // print 2
	...
</pre>

<h3>Global Context</h3>

<p>
When a variable is not found in the local context or in the local function environment, it is a global. A global can be accessed through the whole file, it is shared among all code.
</p>

<pre>
	f = function() {
		$print(x);
		x += 1;
	}
	x = 0;
	f(); // print 0
	f(); // print 1
	$print(x); // print 2
</pre>

<p>
It might be useful to add primitives that can direclty access the global context.
</p>

<h2>Basic Types Operations</h2>

<p>
Basic types are numbers (int and float), booleans (bool), the null value, strings, objects, arrays and functions. There are several operations available to use them, see the following tables. On the row is first operand type and on the columns is second operand type. The result is either the type of the returned value, or "concat" if we use string concatenation (in that case the two values are converted to strings and then concatened together). The "-" means that the operation is invalid and will return <code>null</code>.
</p>

<h3>Arithmetic operations</h3>

<p>
Operation add ( + ) :
</p>

<table border="1" cellspacing="0" cellpadding="4">
<tr>
	<th> + </th>
	<th>null</th>
	<th>int</th>
	<th>float</th>
	<th>string</th>
	<th>bool</th>
	<th>object</th>
	<th>array</th>
	<th>function</th>
</tr>
<tr>
	<th>null</th>
	<td>-</td>
	<td>-</td>
	<td>-</td>
	<td>concat</td>
	<td>-</td>
	<td>-</td>
	<td>-</td>
	<td>-</td>
</tr>
<tr>
	<th>int</th>
	<td>-</td>
	<td>int</td>
	<td>float</td>
	<td>concat</td>
	<td>-</td>
	<td>-</td>
	<td>-</td>
	<td>-</td>
</tr>
<tr>
	<th>float</th>
	<td>-</td>
	<td>float</td>
	<td>float</td>
	<td>concat</td>
	<td>-</td>
	<td>-</td>
	<td>-</td>
	<td>-</td>
</tr>
<tr>
	<th>string</th>
	<td>concat</td>
	<td>concat</td>
	<td>concat</td>
	<td>concat</td>
	<td>concat</td>
	<td>concat</td>
	<td>concat</td>
	<td>concat</td>
</tr>
<tr>
	<th>bool</th>
	<td>-</td>
	<td>-</td>
	<td>-</td>
	<td>concat</td>
	<td>-</td>
	<td>-</td>
	<td>-</td>
	<td>-</td>
</tr>
<tr>
	<th>object</th>
	<td>-</td>
	<td>-</td>
	<td>-</td>
	<td>concat</td>
	<td>-</td>
	<td>-</td>
	<td>-</td>
	<td>-</td>
</tr>
<tr>
	<th>array</th>
	<td>-</td>
	<td>-</td>
	<td>-</td>
	<td>concat</td>
	<td>-</td>
	<td>-</td>
	<td>-</td>
	<td>-</td>
</tr>
<tr>
	<th>function</th>
	<td>-</td>
	<td>-</td>
	<td>-</td>
	<td>concat</td>
	<td>-</td>
	<td>-</td>
	<td>-</td>
	<td>-</td>
</tr>
</table>

<p>
Operations substract ( - ) divide ( / ) multiply ( * ) and modulo ( % ) :
</p>


<table border="1" cellspacing="0" cellpadding="4">
<tr>
	<th> - / * % </th>
	<th>int</th>
	<th>float</th>
</tr>
<tr>
	<th>int</th>
	<td>int</td>
	<td>float</td>
</tr>
<tr>
	<th>float</th>
	<td>float</td>
	<td>float</td>
</tr>
</table>

<p>
	Please note that unlike some languages, the divide operation between two integers does not returns a float. You can use the <code>$div</code> primitive that always performs float division :
</p>

<pre>
	$print(7/2); // prints 3
	$print($div(7,2)); // prints 3.5
</pre>

<p>
	Dividing or doing modulo of one integer by the integer zero returns <code>null</code>. For floats, it's hardware dependant and usually return the float +infinity. You can test it using the primitive <code>$isInf</code> :
</p>

<pre>
	$print(1/0); // prints null
	$print($isInf(1.0/0)); // prints true
</pre>

<p>
	Please note also that overflow on integer operations does not convert them to floats and are not catchable errors. If you want to control overflow you can define your own functions for operations or use floats everywhere.
</p>

<h3>Bitwise operations</h3>

<p>
	The following operations are available for integers only, the perform on a bit basis. Please remember that for performances reasons, Neko integers are signed and 31 bits only, so there is only 30 bits of "unsigned" part :
</p>

<ul>
	<li><code>&lt;&lt;</code> left bit shift</li>
	<li><code>&gt;&gt;</code> right bit shift</li>
	<li><code>&gt;&gt;&gt;</code> right unsigned bit shift</li>
	<li><code>|</code> or bits</li>
	<li><code>&</code> and bits</li>
	<li><code>^</code> xor bits</li>
</ul>

<p>
	Using the operations if one of the two operands is not an integer returns null.
</p>

<h3>Boolean operations</h3>

<p>
	Before applying a boolean operation such as <code>&&</code> and <code>||</code>, values are converted to booleans using the following rules :
</p>

<ul>
	<li>null : false</li>
	<li>int : false if 0, true either</li>
	<li>float : true</li>
	<li>string : true</li>
	<li>bool : itself</li>
	<li>object : true</li>
	<li>array : true</li>
	<li>function : true</li>
</ul>

<p>
	As you can see, only the values <code>null</code>, the boolean <code>false</code> and the integer <code>0</code> evaluates to false. You can use the primitive <code>$isTrue</code> to get the corresponding boolean from any value.
</p>

<p>
	Operation BooleanAnd ( && ) :
</p>

<table border="1" cellspacing="0" cellpadding="4">
<tr>
	<th> &&</th>
	<th>true</th>
	<th>false</th>
</tr>
<tr>
	<th>true</th>
	<td>true</td>
	<td>false</td>
</tr>
<tr>
	<th>false</th>
	<td>false</td>
	<td>false</td>
</tr>
</table>

<p>
	Operation BooleanOr ( || ) :
</p>

<table border="1" cellspacing="0" cellpadding="4">
<tr>
	<th> ||</th>
	<th>true</th>
	<th>false</th>
</tr>
<tr>
	<th>true</th>
	<td>true</td>
	<td>true</td>
</tr>
<tr>
	<th>false</th>
	<td>true</td>
	<td>false</td>
</tr>
</table>

<p>
	Note : boolean operations are short-circuited. That means that if the first operand of an <code>&&</code> evaluates to <code>false</code> or the first operand of an <code>||</code> evaluated to <code>true</code>, than the second operand is not evaluated.
</p>

<p>
	<em>For better performances, it might be useful to add primitives that does not do the isTrue conversion but directly test "true" equality</em>
</p>

<h3>Equality & Comparisons</h3>

<p>
	Physical comparison occurs when the following operations are performed : equality <code>==</code>, difference<code>!=</code>, greater <code>&gt;</code>, lower <code>&lt;</code>, greater or equal <code>
</p>

<p>
	Physical comparison method :
</p>


<table border="1" cellspacing="0" cellpadding="4">
<tr>
	<th> $compare </th>
	<th>null</th>
	<th>int</th>
	<th>float</th>
	<th>string</th>
	<th>bool</th>
	<th>object</th>
	<th>array</th>
	<th>function</th>
</tr>
<tr>
	<th>null</th>
	<td>0</td>
	<td>-</td>
	<td>-</td>
	<td>-</td>
	<td>-</td>
	<td>-</td>
	<td>-</td>
	<td>-</td>
</tr>
<tr>
	<th>int</th>
	<td>-</td>
	<td>icmp</td>
	<td>fcmp</td>
	<td>strcmp</td>
	<td>-</td>
	<td>-</td>
	<td>-</td>
	<td>-</td>
</tr>
<tr>
	<th>float</th>
	<td>-</td>
	<td>fcmp</td>
	<td>fcmp</td>
	<td>strcmp</td>
	<td>-</td>
	<td>-</td>
	<td>-</td>
	<td>-</td>
</tr>
<tr>
	<th>string</th>
	<td>-</td>
	<td>strcmp</td>
	<td>strcmp</td>
	<td>strcmp</td>
	<td>strcmp</td>
	<td>-</td>
	<td>-</td>
	<td>-</td>
</tr>
<tr>
	<th>bool</th>
	<td>-</td>
	<td>-</td>
	<td>-</td>
	<td>strcmp</td>
	<td>bcmp</td>
	<td>-</td>
	<td>-</td>
	<td>-</td>
</tr>
<tr>
	<th>object</th>
	<td>-</td>
	<td>-</td>
	<td>-</td>
	<td>-</td>
	<td>-</td>
	<td>acmp</td>
	<td>-</td>
	<td>-</td>
</tr>
<tr>
	<th>array</th>
	<td>-</td>
	<td>-</td>
	<td>-</td>
	<td>-</td>
	<td>-</td>
	<td>-</td>
	<td>acmp</td>
	<td>-</td>
</tr>
<tr>
	<th>function</th>
	<td>-</td>
	<td>-</td>
	<td>-</td>
	<td>-</td>
	<td>-</td>
	<td>-</td>
	<td>-</td>
	<td>acmp</td>
</tr>
</table>

<p>
	Here's the detail of each comparison function :
</p>

<ul>
	<li>icmp compare two integers a and b, returns 0 if they're equal, -1 if b &gt; a and 1 if a &gt; b</li>
	<li>fcmp is the same as icmp but compares floats instead of integers</li>
	<li>strcmp compares strings, it can be seen as a icmp applied to every byte of the two strings</li>
	<li>acmp compares two addresses a and b,  returns 0 if they're the same, -1 if b &gt; a and 1 if a &gt; b</li>
	<li> - means that the comparison is invalid, the returned value is null</li>
</ul>

<p>
	The following table show how each operation is performing depending on the result of <code>$compare</code> :
</p>

<table border="1" cellspacing="0" cellpadding="4">
<tr>
	<th> op </th>
	<th>null</th>
	<th>-1</th>
	<th>0</th>
	<th>1</th>
</tr>
<tr>
	<th> == </th>
	<td>false</th>
	<td>false</th>
	<td>true</th>
	<td>false</th>
</tr>
<tr>
	<th> != </th>
	<td>true</th>
	<td>true</th>
	<td>false</th>
	<td>true</th>
</tr>
<tr>
	<th> &lt;= </th>
	<td>false</th>
	<td>true</th>
	<td>true</th>
	<td>false</th>
</tr>
<tr>
	<th> &lt; </th>
	<td>false</th>
	<td>true</th>
	<td>false</th>
	<td>false</th>
</tr>
<tr>
	<th> &gt;= </th>
	<td>false</th>
	<td>false</th>
	<td>true</th>
	<td>true</th>
</tr>
<tr>
	<th> &gt; </th>
	<td>false</th>
	<td>false</th>
	<td>true</th>
	<td>true</th>
</tr>
</table>

<p>
	<em>Note : need to add structural comparison in the language</em>
</p>

<h2>Function & Function Calls</h2>

<p>
Defining new functions is easy, since functions are values, you can simply assign them to a local or a global variable :
</p>

<pre>
	var foo = function() {
		return 0;
	}
</pre>

<p>
	Functions are called by-value, that means that <code>foo(1)</code> calls the function which is the value of the variable foo. Calling a value that is not a function or that does not accept this number of arguments returns a <code>null</code> value. You can use the <code>$isfun</code> primitive to add a runtime check that will raise an exception if the value is not a function or if the number of arguments is not correct, and that will simply returns the function either :
</p>

<pre>
	var foo = 3;
	foo(); // null
	$isfun(foo,0); // exception

	var foo = function() { return 0; };
	foo(3); // null
	$isfun(foo,1)(3); // exception
	$isfun(foo,0)(); // ok
</pre>

<p>
	You can know the number of arguments needed by a function by using the primitive <code>$nargs</code>. A function that accepts a variable number of arguments returns -1 when used with <code>$nargs</code>. Please note also that primitives can be used as values :
</p>

<pre>
	$print($nargs(function(a,b) { return a + b; }); // prints 2
	$print($nargs($callopt)); // prints -1
	$print($nargs(0)); // prints null

	$isfun($callopt,3); // ok, since we can call $callopt with 3 arguments
</pre>

<p>
	<em>Note :It might be useful to provide syntax so the user can define its own variable arguments functions.</em>
</p>

<p>
	There is one other way of calling a function : primitive <code>$call</code> takes an array of arguments and a object context (see Objects section) as parameters. This primitive can be useful for introspection :
</p>

<pre>
	$call(foo,null,$array(3,4)); // call the foo function with null context and two parameters 3 and 4
</pre>

<p>
	A function call is successful only if the value is a function and is called with the exact number of arguments needed. In you need optional arguments, you can use the primitive <code>$callopt</code> that will call the function, adding <code>null</code> arguments if missing and ignoring additional arguments :
</p>

<pre>
	var foo = function(x,y) { $print(x+y) };
	foo(3); // null
	$callopt(foo,null,$array(3)); // call foo(3,null) with null context : prints "null"
	$callopt(foo,null,$array(3,4,5)); // call foo(3,4) with null context : prints "7"
	$callopt(null,null); // null
</pre>

<p>
	Some languages might want more security about the types of the arguments that are passed to a function, or selecting at runtime different implementations of a function depending on the type of the arguments. There are many ways of doing that in Neko. For example, you might want to add arguments checks at the beginning of the function body using runtime types informations (RTTI) primitives.
</p>

<h2>Objects</h2>

<p>
	Objects are some kind of optimized hashtables. All fields names are hashed into an integer value that is used as the key into a lookup table. Insertion of a new field is <code>O(n)</code>, access to a field is <code>O(log n)</code>. If you're generating from a staticly typed programming language, you might prefer arrays for storing fields, since they provide <code>O(1)</code> access.
</p>

<p>
	To create an object, you can use the primitive <code>$new</code>, that can either returns a copy of an object or a new object :
</p>

<pre>
	o = $new(null); // new empty object
	o2 = $new(o); // makes a copy of o
	o2 = $new(33); // if parameter is not an object, returns null
</pre>

<p>
	You can set fields of an object using dot access or using the primitive <code>$objset</code> :
</p>

<pre>
	o.field = value;
	$objset(o,"field",value);
	$objset(o, 33, value); // null
</pre>

<p>
	Accessing object fields for reading use either dot access or primitive <code>$objget</code> :
</p>

<pre>
	o.field; // returns "field" value of object o
	$objget(o,"field"); // returns "field" value of object o
	$objget(o, 33); // null
</pre>

<p>
	Please note that <code>$objset</code> and <code>$objget</code> second parameter is evaluated and hashed at runtime so it's a less efficient operation than dot access but enables introspection.
</p>

<p>
	If a field is not defined when accessed for reading, the <code>null</code> value is returned. If a field does not exists when a field is accessed for writing, the field is added. If you want safe accesses that ensure that no field is added and that no field is accessed if it doesn't exists, you can use the primitives <code>$safeget</code> and <code>$safeset</code> that throw exceptions if the field doesn't exist.
</p>

<p>
	To check for a field existance, you can use the <code>$haveField</code> primitive that checks if an object o have a given field, even if that field is set to the <code>null</code> value :
</p>

<pre>
	$haveField(o,"field"); // true if o have "field"
	$haveField(o,33); // false
	$haveField(null,33); // false
</pre>

<h3>Methods</h3>

<p>
	When a function is called using the dot access or the primitive <code>$objcall</code>, the function can access a special variable named <code>this</code> which is the "object context" (the object with which the function was called) :
</p>

<pre>
	o = $new(null);
	o.x = 1;
	o.add = function(y) { return this.x + y; }
	$print(o.add(2)); // prints 3
	$print( $objcall(o,"add",$array(2)) ); // prints 3
</pre>

<p>
	There is also a way to call methods with ensuring that the object have the method with the correct number of arguments :
</p>

<pre>
	$safecall(o,"add",$array()); // exception
	$safecall(o,"add",$array(2)); // prints 3
	$safecall(o,"add",$array(2,3)); // exception
</pre>

<p>
	The context value <code>this</code>, like true or false, cannot be modified directly. The context is set when a object function is called and can be accessed from any sub function :
</p>

<pre>
	foo = function() {
		$print(this.x);
	}
	o = $new(null);
	o.x = 3;
	o.bar = function() { foo(); };
	o.bar(); // prints 3
</pre>

<p>
	You can modify the value of <code>this</code> at runtime by using the primitive <code>$setThis</code>. It can be set to any value, not only objects. When returning from an object call, the context is restored, so any modifications are lost :
</p>

<pre>
	$setThis(1);
	o.foo = function() {
		// this = o
		$setThis(2);
		// this = 2
	};
	o.foo();
	$print(this); // 1
</pre>

<h3>Fields lists</h3>

<p>
	As explained before, fields names are first hashed into integer values for faster access. In order to avoid collisions in the hashing functions, they are then stored into a global table than will check that hash(x) = hash(y) implies that x = y. The other utility of this library is to be able to reverse the hashing function at runtime, that can be useful to print the field names of an object, for debugging purpose for example.
</p>

<p>
	You can use the following primitives : <code>$hash</code> returns the integer hashing value of a string, or raise an exception in case of collision. <code>$field<code> transforms an integer into a previously hashed string or returns null.
</p>

<h2>Macros</h2>

<p>
When you want to generate from another language to Neko, you might need some syntactic shortcuts for operations that are often used. For example let's imagine a language where the empty string evaluate to <code>false</code>, that means that in Neko for each test (if, while...) you will have to test for <code>true</code> and for the empty string. Macros enable you to do that easily :
</p>

<pre>
	is_true = function(x) {
		x && x != ""
	}
	...
	if( 'is_true(...) )
		...
</pre>

<p>
As you noticed, macro are function which are called with an preceding quote, that means that the macro will be expanded before even starting execution, so you will not call function is_true actually, but replace its contents by the corresponding expression. Let's see how it works :
</p>

<pre>
	if( 'is_true(33) )
</pre>

<p>
Will be turned into :
</p>

<pre>
	if( { 33 && 33 != "" } )
</pre>

<p>
Please note that the last syntactic assignment of "is_true" is used as macro. That means that macros generation are not done at runtime and that the value of <code>is_true</code> at the time the <code>if</code> is evaluated will not change anything. Another thing, is that you have to be careful about macros, since in previous case 33 is evaluated twice, macro expansion can break some code :
</p>

<pre>
	if( 'is_true(f(x)) )
</pre>

<p>
Expands to :
</p>

<pre>
	if( { f(x) && f(x) != "" } )
</pre>

<p>
Which is wrong, since we don't want to evaluate twice the expression, or call twice the function in this case. We need then to redefine the macro is_true this way :
</p>

<pre>
	is_true = function(x) {
		var tmp = x;
		tmp && tmp != ""
	}
</pre>

<p>
Now previous case correctly expands to :
</p>

<pre>
	if( { var tmp = f(x); tmp && tmp != "" } )
</pre>

<p>
Please note that macros can't really define new variables since every macro expansion will be enclosed into curly braced block that will prevent them from escaping the scope.
</p>

<p>
In such case, the naming of the variable <code>tmp</code> is not important, since we're evaluating f(x) before adding it to the scope, it can't then hide or replace an user define variable. But in some more complex macros that can be the case. Macro locals variables have then to be carefuly chosen. (<em>or maybe the Neko macro expander should rename macros local variables with unique name, which will guarantee that they will not break</em>).
</p>

<p>
-- TODO --
</p>

<ul>
<li>Arrays : (exceptions on bounds, primitives)</li>
<li>Strings : primitives</li>
<li>Numbers : primitives</li>
<li>Primitives, optimizations, accés C, $print $callfun $callopt $throw</li>
<li>RTTI & introspection</li>
<li>Modules</li>
<li>Exceptions : handlers</li>
<li>Hashtbls : dans le language ?</li>
</ul>

<i>(c)2004-2005 Nicolas Cannasse</i>

</body>
</html>
